commit 6c8120c5ff130e03d32ff15a8f0d0e703592a2af
Author: Jason Merrill <jason@redhat.com>
Date:   Sat Dec 22 19:06:34 2018 -0500

    Remove support for demangling GCC 2.x era mangling schemes.
    
    libiberty/
            * cplus-dem.c: Remove cplus_mangle_opname, cplus_demangle_opname,
            internal_cplus_demangle, and all subroutines.
            (libiberty_demanglers): Remove entries for ancient GNU (pre-3.0),
            Lucid, ARM, HP, and EDG demangling styles.
            (cplus_demangle): Remove 'work' variable.  Don't call
            internal_cplus_demangle.
    include/
            * demangle.h: Remove support for ancient GNU (pre-3.0), Lucid,
            ARM, HP, and EDG demangling styles.
    
    From-SVN: r267363

--- include/demangle.h
+++ include/demangle.h
@@ -53,20 +53,13 @@ extern "C" {
 					   */
 
 #define DMGL_AUTO	 (1 << 8)
-#define DMGL_GNU	 (1 << 9)
-#define DMGL_LUCID	 (1 << 10)
-#define DMGL_ARM	 (1 << 11)
-#define DMGL_HP 	 (1 << 12)       /* For the HP aCC compiler;
-                                            same as ARM except for
-                                            template arguments, etc. */
-#define DMGL_EDG	 (1 << 13)
 #define DMGL_GNU_V3	 (1 << 14)
 #define DMGL_GNAT	 (1 << 15)
 #define DMGL_DLANG	 (1 << 16)
 #define DMGL_RUST	 (1 << 17)	/* Rust wraps GNU_V3 style mangling.  */
 
 /* If none of these are set, use 'current_demangling_style' as the default. */
-#define DMGL_STYLE_MASK (DMGL_AUTO|DMGL_GNU|DMGL_LUCID|DMGL_ARM|DMGL_HP|DMGL_EDG|DMGL_GNU_V3|DMGL_JAVA|DMGL_GNAT|DMGL_DLANG|DMGL_RUST)
+#define DMGL_STYLE_MASK (DMGL_AUTO|DMGL_GNU_V3|DMGL_JAVA|DMGL_GNAT|DMGL_DLANG|DMGL_RUST)
 
 /* Enumeration of possible demangling styles.
 
@@ -92,11 +85,6 @@ extern enum demangling_styles
   no_demangling = -1,
   unknown_demangling = 0,
   auto_demangling = DMGL_AUTO,
-  gnu_demangling = DMGL_GNU,
-  lucid_demangling = DMGL_LUCID,
-  arm_demangling = DMGL_ARM,
-  hp_demangling = DMGL_HP,
-  edg_demangling = DMGL_EDG,
   gnu_v3_demangling = DMGL_GNU_V3,
   java_demangling = DMGL_JAVA,
   gnat_demangling = DMGL_GNAT,
@@ -108,11 +96,6 @@ extern enum demangling_styles
 
 #define NO_DEMANGLING_STYLE_STRING            "none"
 #define AUTO_DEMANGLING_STYLE_STRING	      "auto"
-#define GNU_DEMANGLING_STYLE_STRING    	      "gnu"
-#define LUCID_DEMANGLING_STYLE_STRING	      "lucid"
-#define ARM_DEMANGLING_STYLE_STRING	      "arm"
-#define HP_DEMANGLING_STYLE_STRING	      "hp"
-#define EDG_DEMANGLING_STYLE_STRING	      "edg"
 #define GNU_V3_DEMANGLING_STYLE_STRING        "gnu-v3"
 #define JAVA_DEMANGLING_STYLE_STRING          "java"
 #define GNAT_DEMANGLING_STYLE_STRING          "gnat"
@@ -123,11 +106,6 @@ extern enum demangling_styles
 
 #define CURRENT_DEMANGLING_STYLE current_demangling_style
 #define AUTO_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_AUTO)
-#define GNU_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_GNU)
-#define LUCID_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_LUCID)
-#define ARM_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_ARM)
-#define HP_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_HP)
-#define EDG_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_EDG)
 #define GNU_V3_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_GNU_V3)
 #define JAVA_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_JAVA)
 #define GNAT_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_GNAT)
@@ -147,17 +125,8 @@ extern const struct demangler_engine
 extern char *
 cplus_demangle (const char *mangled, int options);
 
-extern int
-cplus_demangle_opname (const char *opname, char *result, int options);
-
-extern const char *
-cplus_mangle_opname (const char *opname, int options);
-
 /* Note: This sets global state.  FIXME if you care about multi-threading. */
 
-extern void
-set_cplus_marker_for_demangling (int ch);
-
 extern enum demangling_styles
 cplus_demangle_set_style (enum demangling_styles style);
 
--- libiberty/cplus-dem.c
+++ libiberty/cplus-dem.c
@@ -29,12 +29,6 @@ License along with libiberty; see the file COPYING.LIB.  If
 not, write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor,
 Boston, MA 02110-1301, USA.  */
 
-/* This file exports two functions; cplus_mangle_opname and cplus_demangle.
-
-   This file imports xmalloc and xrealloc, which are like malloc and
-   realloc except that they generate a fatal error if there is no
-   available memory.  */
-
 /* This file lives in both GCC and libiberty.  When making changes, please
    try not to break either.  */
 
@@ -44,9 +38,7 @@ Boston, MA 02110-1301, USA.  */
 
 #include "safe-ctype.h"
 
-#include <sys/types.h>
 #include <string.h>
-#include <stdio.h>
 
 #ifdef HAVE_STDLIB_H
 #include <stdlib.h>
@@ -55,204 +47,14 @@ void * malloc ();
 void * realloc ();
 #endif
 
-#ifdef HAVE_LIMITS_H
-#include <limits.h>
-#endif
-#ifndef INT_MAX
-# define INT_MAX       (int)(((unsigned int) ~0) >> 1)          /* 0x7FFFFFFF */ 
-#endif
-
 #include <demangle.h>
 #undef CURRENT_DEMANGLING_STYLE
-#define CURRENT_DEMANGLING_STYLE work->options
+#define CURRENT_DEMANGLING_STYLE options
 
 #include "libiberty.h"
 
-#define min(X,Y) (((X) < (Y)) ? (X) : (Y))
-
-/* A value at least one greater than the maximum number of characters
-   that will be output when using the `%d' format with `printf'.  */
-#define INTBUF_SIZE 32
-
-extern void fancy_abort (void) ATTRIBUTE_NORETURN;
-
-/* In order to allow a single demangler executable to demangle strings
-   using various common values of CPLUS_MARKER, as well as any specific
-   one set at compile time, we maintain a string containing all the
-   commonly used ones, and check to see if the marker we are looking for
-   is in that string.  CPLUS_MARKER is usually '$' on systems where the
-   assembler can deal with that.  Where the assembler can't, it's usually
-   '.' (but on many systems '.' is used for other things).  We put the
-   current defined CPLUS_MARKER first (which defaults to '$'), followed
-   by the next most common value, followed by an explicit '$' in case
-   the value of CPLUS_MARKER is not '$'.
-
-   We could avoid this if we could just get g++ to tell us what the actual
-   cplus marker character is as part of the debug information, perhaps by
-   ensuring that it is the character that terminates the gcc<n>_compiled
-   marker symbol (FIXME).  */
-
-#if !defined (CPLUS_MARKER)
-#define CPLUS_MARKER '$'
-#endif
-
 enum demangling_styles current_demangling_style = auto_demangling;
 
-static char cplus_markers[] = { CPLUS_MARKER, '.', '$', '\0' };
-
-static char char_str[2] = { '\000', '\000' };
-
-void
-set_cplus_marker_for_demangling (int ch)
-{
-  cplus_markers[0] = ch;
-}
-
-typedef struct string		/* Beware: these aren't required to be */
-{				/*  '\0' terminated.  */
-  char *b;			/* pointer to start of string */
-  char *p;			/* pointer after last character */
-  char *e;			/* pointer after end of allocated space */
-} string;
-
-/* Stuff that is shared between sub-routines.
-   Using a shared structure allows cplus_demangle to be reentrant.  */
-
-struct work_stuff
-{
-  int options;
-  char **typevec;
-  char **ktypevec;
-  char **btypevec;
-  int numk;
-  int numb;
-  int ksize;
-  int bsize;
-  int ntypes;
-  int typevec_size;
-  int constructor;
-  int destructor;
-  int static_type;	/* A static member function */
-  int temp_start;       /* index in demangled to start of template args */
-  int type_quals;       /* The type qualifiers.  */
-  int dllimported;	/* Symbol imported from a PE DLL */
-  char **tmpl_argvec;   /* Template function arguments. */
-  int ntmpl_args;       /* The number of template function arguments. */
-  int forgetting_types; /* Nonzero if we are not remembering the types
-			   we see.  */
-  string* previous_argument; /* The last function argument demangled.  */
-  int nrepeats;         /* The number of times to repeat the previous
-			   argument.  */
-  int *proctypevec;     /* Indices of currently processed remembered typevecs.  */
-  int proctypevec_size;
-  int nproctypes;
-};
-
-#define PRINT_ANSI_QUALIFIERS (work -> options & DMGL_ANSI)
-#define PRINT_ARG_TYPES       (work -> options & DMGL_PARAMS)
-
-static const struct optable
-{
-  const char *const in;
-  const char *const out;
-  const int flags;
-} optable[] = {
-  {"nw",	  " new",	DMGL_ANSI},	/* new (1.92,	 ansi) */
-  {"dl",	  " delete",	DMGL_ANSI},	/* new (1.92,	 ansi) */
-  {"new",	  " new",	0},		/* old (1.91,	 and 1.x) */
-  {"delete",	  " delete",	0},		/* old (1.91,	 and 1.x) */
-  {"vn",	  " new []",	DMGL_ANSI},	/* GNU, pending ansi */
-  {"vd",	  " delete []",	DMGL_ANSI},	/* GNU, pending ansi */
-  {"as",	  "=",		DMGL_ANSI},	/* ansi */
-  {"ne",	  "!=",		DMGL_ANSI},	/* old, ansi */
-  {"eq",	  "==",		DMGL_ANSI},	/* old,	ansi */
-  {"ge",	  ">=",		DMGL_ANSI},	/* old,	ansi */
-  {"gt",	  ">",		DMGL_ANSI},	/* old,	ansi */
-  {"le",	  "<=",		DMGL_ANSI},	/* old,	ansi */
-  {"lt",	  "<",		DMGL_ANSI},	/* old,	ansi */
-  {"plus",	  "+",		0},		/* old */
-  {"pl",	  "+",		DMGL_ANSI},	/* ansi */
-  {"apl",	  "+=",		DMGL_ANSI},	/* ansi */
-  {"minus",	  "-",		0},		/* old */
-  {"mi",	  "-",		DMGL_ANSI},	/* ansi */
-  {"ami",	  "-=",		DMGL_ANSI},	/* ansi */
-  {"mult",	  "*",		0},		/* old */
-  {"ml",	  "*",		DMGL_ANSI},	/* ansi */
-  {"amu",	  "*=",		DMGL_ANSI},	/* ansi (ARM/Lucid) */
-  {"aml",	  "*=",		DMGL_ANSI},	/* ansi (GNU/g++) */
-  {"convert",	  "+",		0},		/* old (unary +) */
-  {"negate",	  "-",		0},		/* old (unary -) */
-  {"trunc_mod",	  "%",		0},		/* old */
-  {"md",	  "%",		DMGL_ANSI},	/* ansi */
-  {"amd",	  "%=",		DMGL_ANSI},	/* ansi */
-  {"trunc_div",	  "/",		0},		/* old */
-  {"dv",	  "/",		DMGL_ANSI},	/* ansi */
-  {"adv",	  "/=",		DMGL_ANSI},	/* ansi */
-  {"truth_andif", "&&",		0},		/* old */
-  {"aa",	  "&&",		DMGL_ANSI},	/* ansi */
-  {"truth_orif",  "||",		0},		/* old */
-  {"oo",	  "||",		DMGL_ANSI},	/* ansi */
-  {"truth_not",	  "!",		0},		/* old */
-  {"nt",	  "!",		DMGL_ANSI},	/* ansi */
-  {"postincrement","++",	0},		/* old */
-  {"pp",	  "++",		DMGL_ANSI},	/* ansi */
-  {"postdecrement","--",	0},		/* old */
-  {"mm",	  "--",		DMGL_ANSI},	/* ansi */
-  {"bit_ior",	  "|",		0},		/* old */
-  {"or",	  "|",		DMGL_ANSI},	/* ansi */
-  {"aor",	  "|=",		DMGL_ANSI},	/* ansi */
-  {"bit_xor",	  "^",		0},		/* old */
-  {"er",	  "^",		DMGL_ANSI},	/* ansi */
-  {"aer",	  "^=",		DMGL_ANSI},	/* ansi */
-  {"bit_and",	  "&",		0},		/* old */
-  {"ad",	  "&",		DMGL_ANSI},	/* ansi */
-  {"aad",	  "&=",		DMGL_ANSI},	/* ansi */
-  {"bit_not",	  "~",		0},		/* old */
-  {"co",	  "~",		DMGL_ANSI},	/* ansi */
-  {"call",	  "()",		0},		/* old */
-  {"cl",	  "()",		DMGL_ANSI},	/* ansi */
-  {"alshift",	  "<<",		0},		/* old */
-  {"ls",	  "<<",		DMGL_ANSI},	/* ansi */
-  {"als",	  "<<=",	DMGL_ANSI},	/* ansi */
-  {"arshift",	  ">>",		0},		/* old */
-  {"rs",	  ">>",		DMGL_ANSI},	/* ansi */
-  {"ars",	  ">>=",	DMGL_ANSI},	/* ansi */
-  {"component",	  "->",		0},		/* old */
-  {"pt",	  "->",		DMGL_ANSI},	/* ansi; Lucid C++ form */
-  {"rf",	  "->",		DMGL_ANSI},	/* ansi; ARM/GNU form */
-  {"indirect",	  "*",		0},		/* old */
-  {"method_call",  "->()",	0},		/* old */
-  {"addr",	  "&",		0},		/* old (unary &) */
-  {"array",	  "[]",		0},		/* old */
-  {"vc",	  "[]",		DMGL_ANSI},	/* ansi */
-  {"compound",	  ", ",		0},		/* old */
-  {"cm",	  ", ",		DMGL_ANSI},	/* ansi */
-  {"cond",	  "?:",		0},		/* old */
-  {"cn",	  "?:",		DMGL_ANSI},	/* pseudo-ansi */
-  {"max",	  ">?",		0},		/* old */
-  {"mx",	  ">?",		DMGL_ANSI},	/* pseudo-ansi */
-  {"min",	  "<?",		0},		/* old */
-  {"mn",	  "<?",		DMGL_ANSI},	/* pseudo-ansi */
-  {"nop",	  "",		0},		/* old (for operator=) */
-  {"rm",	  "->*",	DMGL_ANSI},	/* ansi */
-  {"sz",          "sizeof ",    DMGL_ANSI}      /* pseudo-ansi */
-};
-
-/* These values are used to indicate the various type varieties.
-   They are all non-zero so that they can be used as `success'
-   values.  */
-typedef enum type_kind_t
-{
-  tk_none,
-  tk_pointer,
-  tk_reference,
-  tk_rvalue_reference,
-  tk_integral,
-  tk_bool,
-  tk_char,
-  tk_real
-} type_kind_t;
-
 const struct demangler_engine libiberty_demanglers[] =
 {
   {
@@ -268,39 +70,9 @@ const struct demangler_engine libiberty_
   }
   ,
   {
-    GNU_DEMANGLING_STYLE_STRING,
-      gnu_demangling,
-      "GNU (g++) style demangling"
-  }
-  ,
-  {
-    LUCID_DEMANGLING_STYLE_STRING,
-      lucid_demangling,
-      "Lucid (lcc) style demangling"
-  }
-  ,
-  {
-    ARM_DEMANGLING_STYLE_STRING,
-      arm_demangling,
-      "ARM style demangling"
-  }
-  ,
-  {
-    HP_DEMANGLING_STYLE_STRING,
-      hp_demangling,
-      "HP (aCC) style demangling"
-  }
-  ,
-  {
-    EDG_DEMANGLING_STYLE_STRING,
-      edg_demangling,
-      "EDG style demangling"
-  }
-  ,
-  {
     GNU_V3_DEMANGLING_STYLE_STRING,
     gnu_v3_demangling,
-    "GNU (g++) V3 ABI-style demangling"
+    "GNU (g++) V3 (Itanium C++ ABI) style demangling"
   }
   ,
   {
@@ -332,474 +104,6 @@ const struct demangler_engine libiberty_
   }
 };
 
-#define STRING_EMPTY(str)	((str) -> b == (str) -> p)
-#define APPEND_BLANK(str)	{if (!STRING_EMPTY(str)) \
-    string_append(str, " ");}
-#define LEN_STRING(str)         ( (STRING_EMPTY(str))?0:((str)->p - (str)->b))
-
-/* The scope separator appropriate for the language being demangled.  */
-
-#define SCOPE_STRING(work) ((work->options & DMGL_JAVA) ? "." : "::")
-
-#define ARM_VTABLE_STRING "__vtbl__"	/* Lucid/ARM virtual table prefix */
-#define ARM_VTABLE_STRLEN 8		/* strlen (ARM_VTABLE_STRING) */
-
-/* Prototypes for local functions */
-
-static void delete_work_stuff (struct work_stuff *);
-
-static void delete_non_B_K_work_stuff (struct work_stuff *);
-
-static char *mop_up (struct work_stuff *, string *, int);
-
-static void squangle_mop_up (struct work_stuff *);
-
-static void work_stuff_copy_to_from (struct work_stuff *, struct work_stuff *);
-
-#if 0
-static int
-demangle_method_args (struct work_stuff *, const char **, string *);
-#endif
-
-static char *
-internal_cplus_demangle (struct work_stuff *, const char *);
-
-static int
-demangle_template_template_parm (struct work_stuff *work,
-                                 const char **, string *);
-
-static int
-demangle_template (struct work_stuff *work, const char **, string *,
-                   string *, int, int);
-
-static int
-arm_pt (struct work_stuff *, const char *, int, const char **,
-        const char **);
-
-static int
-demangle_class_name (struct work_stuff *, const char **, string *);
-
-static int
-demangle_qualified (struct work_stuff *, const char **, string *,
-                    int, int);
-
-static int demangle_class (struct work_stuff *, const char **, string *);
-
-static int demangle_fund_type (struct work_stuff *, const char **, string *);
-
-static int demangle_signature (struct work_stuff *, const char **, string *);
-
-static int demangle_prefix (struct work_stuff *, const char **, string *);
-
-static int gnu_special (struct work_stuff *, const char **, string *);
-
-static int arm_special (const char **, string *);
-
-static void string_need (string *, int);
-
-static void string_delete (string *);
-
-static void
-string_init (string *);
-
-static void string_clear (string *);
-
-#if 0
-static int string_empty (string *);
-#endif
-
-static void string_append (string *, const char *);
-
-static void string_appends (string *, string *);
-
-static void string_appendn (string *, const char *, int);
-
-static void string_prepend (string *, const char *);
-
-static void string_prependn (string *, const char *, int);
-
-static void string_append_template_idx (string *, int);
-
-static int get_count (const char **, int *);
-
-static int consume_count (const char **);
-
-static int consume_count_with_underscores (const char**);
-
-static int demangle_args (struct work_stuff *, const char **, string *);
-
-static int demangle_nested_args (struct work_stuff*, const char**, string*);
-
-static int do_type (struct work_stuff *, const char **, string *);
-
-static int do_arg (struct work_stuff *, const char **, string *);
-
-static int
-demangle_function_name (struct work_stuff *, const char **, string *,
-                        const char *);
-
-static int
-iterate_demangle_function (struct work_stuff *,
-                           const char **, string *, const char *);
-
-static void remember_type (struct work_stuff *, const char *, int);
-
-static void push_processed_type (struct work_stuff *, int);
-
-static void pop_processed_type (struct work_stuff *);
-
-static void remember_Btype (struct work_stuff *, const char *, int, int);
-
-static int register_Btype (struct work_stuff *);
-
-static void remember_Ktype (struct work_stuff *, const char *, int);
-
-static void forget_types (struct work_stuff *);
-
-static void forget_B_and_K_types (struct work_stuff *);
-
-static void string_prepends (string *, string *);
-
-static int
-demangle_template_value_parm (struct work_stuff*, const char**,
-                              string*, type_kind_t);
-
-static int
-do_hpacc_template_const_value (struct work_stuff *, const char **, string *);
-
-static int
-do_hpacc_template_literal (struct work_stuff *, const char **, string *);
-
-static int snarf_numeric_literal (const char **, string *);
-
-/* There is a TYPE_QUAL value for each type qualifier.  They can be
-   combined by bitwise-or to form the complete set of qualifiers for a
-   type.  */
-
-#define TYPE_UNQUALIFIED   0x0
-#define TYPE_QUAL_CONST    0x1
-#define TYPE_QUAL_VOLATILE 0x2
-#define TYPE_QUAL_RESTRICT 0x4
-
-static int code_for_qualifier (int);
-
-static const char* qualifier_string (int);
-
-static const char* demangle_qualifier (int);
-
-static int demangle_expression (struct work_stuff *, const char **, string *, 
-                                type_kind_t);
-
-static int
-demangle_integral_value (struct work_stuff *, const char **, string *);
-
-static int
-demangle_real_value (struct work_stuff *, const char **, string *);
-
-static void
-demangle_arm_hp_template (struct work_stuff *, const char **, int, string *);
-
-static void
-recursively_demangle (struct work_stuff *, const char **, string *, int);
-
-/* Translate count to integer, consuming tokens in the process.
-   Conversion terminates on the first non-digit character.
-
-   Trying to consume something that isn't a count results in no
-   consumption of input and a return of -1.
-
-   Overflow consumes the rest of the digits, and returns -1.  */
-
-static int
-consume_count (const char **type)
-{
-  int count = 0;
-
-  if (! ISDIGIT ((unsigned char)**type))
-    return -1;
-
-  while (ISDIGIT ((unsigned char)**type))
-    {
-      const int digit = **type - '0';
-      /* Check for overflow.  */
-      if (count > ((INT_MAX - digit) / 10))
-	{
-	  while (ISDIGIT ((unsigned char) **type))
-	    (*type)++;
-	  return -1;
-	}
-
-      count *= 10;
-      count += digit;
-      (*type)++;
-    }
-
-  if (count < 0)
-    count = -1;
-
-  return (count);
-}
-
-
-/* Like consume_count, but for counts that are preceded and followed
-   by '_' if they are greater than 10.  Also, -1 is returned for
-   failure, since 0 can be a valid value.  */
-
-static int
-consume_count_with_underscores (const char **mangled)
-{
-  int idx;
-
-  if (**mangled == '_')
-    {
-      (*mangled)++;
-      if (!ISDIGIT ((unsigned char)**mangled))
-	return -1;
-
-      idx = consume_count (mangled);
-      if (**mangled != '_')
-	/* The trailing underscore was missing. */
-	return -1;
-
-      (*mangled)++;
-    }
-  else
-    {
-      if (**mangled < '0' || **mangled > '9')
-	return -1;
-
-      idx = **mangled - '0';
-      (*mangled)++;
-    }
-
-  return idx;
-}
-
-/* C is the code for a type-qualifier.  Return the TYPE_QUAL
-   corresponding to this qualifier.  */
-
-static int
-code_for_qualifier (int c)
-{
-  switch (c)
-    {
-    case 'C':
-      return TYPE_QUAL_CONST;
-
-    case 'V':
-      return TYPE_QUAL_VOLATILE;
-
-    case 'u':
-      return TYPE_QUAL_RESTRICT;
-
-    default:
-      break;
-    }
-
-  /* C was an invalid qualifier.  */
-  abort ();
-}
-
-/* Return the string corresponding to the qualifiers given by
-   TYPE_QUALS.  */
-
-static const char*
-qualifier_string (int type_quals)
-{
-  switch (type_quals)
-    {
-    case TYPE_UNQUALIFIED:
-      return "";
-
-    case TYPE_QUAL_CONST:
-      return "const";
-
-    case TYPE_QUAL_VOLATILE:
-      return "volatile";
-
-    case TYPE_QUAL_RESTRICT:
-      return "__restrict";
-
-    case TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE:
-      return "const volatile";
-
-    case TYPE_QUAL_CONST | TYPE_QUAL_RESTRICT:
-      return "const __restrict";
-
-    case TYPE_QUAL_VOLATILE | TYPE_QUAL_RESTRICT:
-      return "volatile __restrict";
-
-    case TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE | TYPE_QUAL_RESTRICT:
-      return "const volatile __restrict";
-
-    default:
-      break;
-    }
-
-  /* TYPE_QUALS was an invalid qualifier set.  */
-  abort ();
-}
-
-/* C is the code for a type-qualifier.  Return the string
-   corresponding to this qualifier.  This function should only be
-   called with a valid qualifier code.  */
-
-static const char*
-demangle_qualifier (int c)
-{
-  return qualifier_string (code_for_qualifier (c));
-}
-
-int
-cplus_demangle_opname (const char *opname, char *result, int options)
-{
-  int len, len1, ret;
-  string type;
-  struct work_stuff work[1];
-  const char *tem;
-
-  len = strlen(opname);
-  result[0] = '\0';
-  ret = 0;
-  memset ((char *) work, 0, sizeof (work));
-  work->options = options;
-
-  if (opname[0] == '_' && opname[1] == '_'
-      && opname[2] == 'o' && opname[3] == 'p')
-    {
-      /* ANSI.  */
-      /* type conversion operator.  */
-      tem = opname + 4;
-      if (do_type (work, &tem, &type))
-	{
-	  strcat (result, "operator ");
-	  strncat (result, type.b, type.p - type.b);
-	  string_delete (&type);
-	  ret = 1;
-	}
-    }
-  else if (opname[0] == '_' && opname[1] == '_'
-	   && ISLOWER((unsigned char)opname[2])
-	   && ISLOWER((unsigned char)opname[3]))
-    {
-      if (opname[4] == '\0')
-	{
-	  /* Operator.  */
-	  size_t i;
-	  for (i = 0; i < ARRAY_SIZE (optable); i++)
-	    {
-	      if (strlen (optable[i].in) == 2
-		  && memcmp (optable[i].in, opname + 2, 2) == 0)
-		{
-		  strcat (result, "operator");
-		  strcat (result, optable[i].out);
-		  ret = 1;
-		  break;
-		}
-	    }
-	}
-      else
-	{
-	  if (opname[2] == 'a' && opname[5] == '\0')
-	    {
-	      /* Assignment.  */
-	      size_t i;
-	      for (i = 0; i < ARRAY_SIZE (optable); i++)
-		{
-		  if (strlen (optable[i].in) == 3
-		      && memcmp (optable[i].in, opname + 2, 3) == 0)
-		    {
-		      strcat (result, "operator");
-		      strcat (result, optable[i].out);
-		      ret = 1;
-		      break;
-		    }
-		}
-	    }
-	}
-    }
-  else if (len >= 3
-	   && opname[0] == 'o'
-	   && opname[1] == 'p'
-	   && strchr (cplus_markers, opname[2]) != NULL)
-    {
-      /* see if it's an assignment expression */
-      if (len >= 10 /* op$assign_ */
-	  && memcmp (opname + 3, "assign_", 7) == 0)
-	{
-	  size_t i;
-	  for (i = 0; i < ARRAY_SIZE (optable); i++)
-	    {
-	      len1 = len - 10;
-	      if ((int) strlen (optable[i].in) == len1
-		  && memcmp (optable[i].in, opname + 10, len1) == 0)
-		{
-		  strcat (result, "operator");
-		  strcat (result, optable[i].out);
-		  strcat (result, "=");
-		  ret = 1;
-		  break;
-		}
-	    }
-	}
-      else
-	{
-	  size_t i;
-	  for (i = 0; i < ARRAY_SIZE (optable); i++)
-	    {
-	      len1 = len - 3;
-	      if ((int) strlen (optable[i].in) == len1
-		  && memcmp (optable[i].in, opname + 3, len1) == 0)
-		{
-		  strcat (result, "operator");
-		  strcat (result, optable[i].out);
-		  ret = 1;
-		  break;
-		}
-	    }
-	}
-    }
-  else if (len >= 5 && memcmp (opname, "type", 4) == 0
-	   && strchr (cplus_markers, opname[4]) != NULL)
-    {
-      /* type conversion operator */
-      tem = opname + 5;
-      if (do_type (work, &tem, &type))
-	{
-	  strcat (result, "operator ");
-	  strncat (result, type.b, type.p - type.b);
-	  string_delete (&type);
-	  ret = 1;
-	}
-    }
-  squangle_mop_up (work);
-  return ret;
-
-}
-
-/* Takes operator name as e.g. "++" and returns mangled
-   operator name (e.g. "postincrement_expr"), or NULL if not found.
-
-   If OPTIONS & DMGL_ANSI == 1, return the ANSI name;
-   if OPTIONS & DMGL_ANSI == 0, return the old GNU name.  */
-
-const char *
-cplus_mangle_opname (const char *opname, int options)
-{
-  size_t i;
-  int len;
-
-  len = strlen (opname);
-  for (i = 0; i < ARRAY_SIZE (optable); i++)
-    {
-      if ((int) strlen (optable[i].out) == len
-	  && (options & DMGL_ANSI) == (optable[i].flags & DMGL_ANSI)
-	  && memcmp (optable[i].out, opname, len) == 0)
-	return optable[i].in;
-    }
-  return (0);
-}
-
 /* Add a routine to set the demangling style to be sure it is valid and
    allow for any demangler initialization that maybe necessary. */
 
@@ -840,22 +144,6 @@ cplus_demangle_name_to_style (const char
    It is the caller's responsibility to free the string which
    is returned.
 
-   The OPTIONS arg may contain one or more of the following bits:
-
-   	DMGL_ANSI	ANSI qualifiers such as `const' and `void' are
-			included.
-	DMGL_PARAMS	Function parameters are included.
-
-   For example,
-
-   cplus_demangle ("foo__1Ai", DMGL_PARAMS)		=> "A::foo(int)"
-   cplus_demangle ("foo__1Ai", DMGL_PARAMS | DMGL_ANSI)	=> "A::foo(int)"
-   cplus_demangle ("foo__1Ai", 0)			=> "A::foo"
-
-   cplus_demangle ("foo__1Afe", DMGL_PARAMS)		=> "A::foo(float,...)"
-   cplus_demangle ("foo__1Afe", DMGL_PARAMS | DMGL_ANSI)=> "A::foo(float,...)"
-   cplus_demangle ("foo__1Afe", 0)			=> "A::foo"
-
    Note that any leading underscores, or other such characters prepended by
    the compilation system, are presumed to have already been stripped from
    MANGLED.  */
@@ -864,20 +152,17 @@ char *
 cplus_demangle (const char *mangled, int options)
 {
   char *ret;
-  struct work_stuff work[1];
 
   if (current_demangling_style == no_demangling)
     return xstrdup (mangled);
 
-  memset ((char *) work, 0, sizeof (work));
-  work->options = options;
-  if ((work->options & DMGL_STYLE_MASK) == 0)
-    work->options |= (int) current_demangling_style & DMGL_STYLE_MASK;
+  if ((options & DMGL_STYLE_MASK) == 0)
+    options |= (int) current_demangling_style & DMGL_STYLE_MASK;
 
   /* The V3 ABI demangling is implemented elsewhere.  */
   if (GNU_V3_DEMANGLING || RUST_DEMANGLING || AUTO_DEMANGLING)
     {
-      ret = cplus_demangle_v3 (mangled, work->options);
+      ret = cplus_demangle_v3 (mangled, options);
       if (GNU_V3_DEMANGLING)
 	return ret;
 
@@ -915,8 +200,6 @@ cplus_demangle (const char *mangled, int
 	return ret;
     }
 
-  ret = internal_cplus_demangle (work, mangled);
-  squangle_mop_up (work);
   return (ret);
 }
 
@@ -1205,3828 +488,3 @@ ada_demangle (const char *mangled, int o
 
   return demangled;
 }
-
-/* This function performs most of what cplus_demangle use to do, but
-   to be able to demangle a name with a B, K or n code, we need to
-   have a longer term memory of what types have been seen. The original
-   now initializes and cleans up the squangle code info, while internal
-   calls go directly to this routine to avoid resetting that info. */
-
-static char *
-internal_cplus_demangle (struct work_stuff *work, const char *mangled)
-{
-
-  string decl;
-  int success = 0;
-  char *demangled = NULL;
-  int s1, s2, s3, s4;
-  s1 = work->constructor;
-  s2 = work->destructor;
-  s3 = work->static_type;
-  s4 = work->type_quals;
-  work->constructor = work->destructor = 0;
-  work->type_quals = TYPE_UNQUALIFIED;
-  work->dllimported = 0;
-
-  if ((mangled != NULL) && (*mangled != '\0'))
-    {
-      string_init (&decl);
-
-      /* First check to see if gnu style demangling is active and if the
-	 string to be demangled contains a CPLUS_MARKER.  If so, attempt to
-	 recognize one of the gnu special forms rather than looking for a
-	 standard prefix.  In particular, don't worry about whether there
-	 is a "__" string in the mangled string.  Consider "_$_5__foo" for
-	 example.  */
-
-      if ((AUTO_DEMANGLING || GNU_DEMANGLING))
-	{
-	  success = gnu_special (work, &mangled, &decl);
-	  if (!success)
-	    {
-	      delete_work_stuff (work);
-	      string_delete (&decl);
-	    }
-	}
-      if (!success)
-	{
-	  success = demangle_prefix (work, &mangled, &decl);
-	}
-      if (success && (*mangled != '\0'))
-	{
-	  success = demangle_signature (work, &mangled, &decl);
-	}
-      if (work->constructor == 2)
-        {
-          string_prepend (&decl, "global constructors keyed to ");
-          work->constructor = 0;
-        }
-      else if (work->destructor == 2)
-        {
-          string_prepend (&decl, "global destructors keyed to ");
-          work->destructor = 0;
-        }
-      else if (work->dllimported == 1)
-        {
-          string_prepend (&decl, "import stub for ");
-          work->dllimported = 0;
-        }
-      demangled = mop_up (work, &decl, success);
-    }
-  work->constructor = s1;
-  work->destructor = s2;
-  work->static_type = s3;
-  work->type_quals = s4;
-  return demangled;
-}
-
-
-/* Clear out and squangling related storage */
-static void
-squangle_mop_up (struct work_stuff *work)
-{
-  /* clean up the B and K type mangling types. */
-  forget_B_and_K_types (work);
-  if (work -> btypevec != NULL)
-    {
-      free ((char *) work -> btypevec);
-      work->btypevec = NULL;
-      work->bsize = 0;
-    }
-  if (work -> ktypevec != NULL)
-    {
-      free ((char *) work -> ktypevec);
-      work->ktypevec = NULL;
-      work->ksize = 0;
-    }
-}
-
-
-/* Copy the work state and storage.  */
-
-static void
-work_stuff_copy_to_from (struct work_stuff *to, struct work_stuff *from)
-{
-  int i;
-
-  delete_work_stuff (to);
-
-  /* Shallow-copy scalars.  */
-  memcpy (to, from, sizeof (*to));
-
-  /* Deep-copy dynamic storage.  */
-  if (from->typevec_size)
-    to->typevec = XNEWVEC (char *, from->typevec_size);
-
-  for (i = 0; i < from->ntypes; i++)
-    {
-      int len = strlen (from->typevec[i]) + 1;
-
-      to->typevec[i] = XNEWVEC (char, len);
-      memcpy (to->typevec[i], from->typevec[i], len);
-    }
-
-  if (from->ksize)
-    to->ktypevec = XNEWVEC (char *, from->ksize);
-
-  for (i = 0; i < from->numk; i++)
-    {
-      int len = strlen (from->ktypevec[i]) + 1;
-
-      to->ktypevec[i] = XNEWVEC (char, len);
-      memcpy (to->ktypevec[i], from->ktypevec[i], len);
-    }
-
-  if (from->bsize)
-    to->btypevec = XNEWVEC (char *, from->bsize);
-
-  for (i = 0; i < from->numb; i++)
-    {
-      int len = strlen (from->btypevec[i]) + 1;
-
-      to->btypevec[i] = XNEWVEC (char , len);
-      memcpy (to->btypevec[i], from->btypevec[i], len);
-    }
-
-  if (from->proctypevec)
-    to->proctypevec =
-      XDUPVEC (int, from->proctypevec, from->proctypevec_size);
-
-  if (from->ntmpl_args)
-    to->tmpl_argvec = XNEWVEC (char *, from->ntmpl_args);
-
-  for (i = 0; i < from->ntmpl_args; i++)
-    {
-      int len = strlen (from->tmpl_argvec[i]) + 1;
-
-      to->tmpl_argvec[i] = XNEWVEC (char, len);
-      memcpy (to->tmpl_argvec[i], from->tmpl_argvec[i], len);
-    }
-
-  if (from->previous_argument)
-    {
-      to->previous_argument = XNEW (string);
-      string_init (to->previous_argument);
-      string_appends (to->previous_argument, from->previous_argument);
-    }
-}
-
-
-/* Delete dynamic stuff in work_stuff that is not to be re-used.  */
-
-static void
-delete_non_B_K_work_stuff (struct work_stuff *work)
-{
-  /* Discard the remembered types, if any.  */
-
-  forget_types (work);
-  if (work->typevec != NULL)
-    {
-      free ((char *) work->typevec);
-      work->typevec = NULL;
-      work->typevec_size = 0;
-    }
-  if (work->proctypevec != NULL)
-    {
-      free (work->proctypevec);
-      work->proctypevec = NULL;
-      work->proctypevec_size = 0;
-    }
-  if (work->tmpl_argvec)
-    {
-      int i;
-
-      for (i = 0; i < work->ntmpl_args; i++)
-	free ((char*) work->tmpl_argvec[i]);
-
-      free ((char*) work->tmpl_argvec);
-      work->tmpl_argvec = NULL;
-    }
-  if (work->previous_argument)
-    {
-      string_delete (work->previous_argument);
-      free ((char*) work->previous_argument);
-      work->previous_argument = NULL;
-    }
-}
-
-
-/* Delete all dynamic storage in work_stuff.  */
-static void
-delete_work_stuff (struct work_stuff *work)
-{
-  delete_non_B_K_work_stuff (work);
-  squangle_mop_up (work);
-}
-
-
-/* Clear out any mangled storage */
-
-static char *
-mop_up (struct work_stuff *work, string *declp, int success)
-{
-  char *demangled = NULL;
-
-  delete_non_B_K_work_stuff (work);
-
-  /* If demangling was successful, ensure that the demangled string is null
-     terminated and return it.  Otherwise, free the demangling decl.  */
-
-  if (!success)
-    {
-      string_delete (declp);
-    }
-  else
-    {
-      string_appendn (declp, "", 1);
-      demangled = declp->b;
-    }
-  return (demangled);
-}
-
-/*
-
-LOCAL FUNCTION
-
-	demangle_signature -- demangle the signature part of a mangled name
-
-SYNOPSIS
-
-	static int
-	demangle_signature (struct work_stuff *work, const char **mangled,
-			    string *declp);
-
-DESCRIPTION
-
-	Consume and demangle the signature portion of the mangled name.
-
-	DECLP is the string where demangled output is being built.  At
-	entry it contains the demangled root name from the mangled name
-	prefix.  I.E. either a demangled operator name or the root function
-	name.  In some special cases, it may contain nothing.
-
-	*MANGLED points to the current unconsumed location in the mangled
-	name.  As tokens are consumed and demangling is performed, the
-	pointer is updated to continuously point at the next token to
-	be consumed.
-
-	Demangling GNU style mangled names is nasty because there is no
-	explicit token that marks the start of the outermost function
-	argument list.  */
-
-static int
-demangle_signature (struct work_stuff *work,
-                    const char **mangled, string *declp)
-{
-  int success = 1;
-  int func_done = 0;
-  int expect_func = 0;
-  int expect_return_type = 0;
-  const char *oldmangled = NULL;
-  string trawname;
-  string tname;
-
-  while (success && (**mangled != '\0'))
-    {
-      switch (**mangled)
-	{
-	case 'Q':
-	  oldmangled = *mangled;
-	  success = demangle_qualified (work, mangled, declp, 1, 0);
-	  if (success)
-	    remember_type (work, oldmangled, *mangled - oldmangled);
-	  if (AUTO_DEMANGLING || GNU_DEMANGLING)
-	    expect_func = 1;
-	  oldmangled = NULL;
-	  break;
-
-        case 'K':
-	  oldmangled = *mangled;
-	  success = demangle_qualified (work, mangled, declp, 1, 0);
-	  if (AUTO_DEMANGLING || GNU_DEMANGLING)
-	    {
-	      expect_func = 1;
-	    }
-	  oldmangled = NULL;
-	  break;
-
-	case 'S':
-	  /* Static member function */
-	  if (oldmangled == NULL)
-	    {
-	      oldmangled = *mangled;
-	    }
-	  (*mangled)++;
-	  work -> static_type = 1;
-	  break;
-
-	case 'C':
-	case 'V':
-	case 'u':
-	  work->type_quals |= code_for_qualifier (**mangled);
-
-	  /* a qualified member function */
-	  if (oldmangled == NULL)
-	    oldmangled = *mangled;
-	  (*mangled)++;
-	  break;
-
-	case 'L':
-	  /* Local class name follows after "Lnnn_" */
-	  if (HP_DEMANGLING)
-	    {
-	      while (**mangled && (**mangled != '_'))
-		(*mangled)++;
-	      if (!**mangled)
-		success = 0;
-	      else
-		(*mangled)++;
-	    }
-	  else
-	    success = 0;
-	  break;
-
-	case '0': case '1': case '2': case '3': case '4':
-	case '5': case '6': case '7': case '8': case '9':
-	  if (oldmangled == NULL)
-	    {
-	      oldmangled = *mangled;
-	    }
-          work->temp_start = -1; /* uppermost call to demangle_class */
-	  success = demangle_class (work, mangled, declp);
-	  if (success)
-	    {
-	      remember_type (work, oldmangled, *mangled - oldmangled);
-	    }
-	  if (AUTO_DEMANGLING || GNU_DEMANGLING || EDG_DEMANGLING)
-	    {
-              /* EDG and others will have the "F", so we let the loop cycle
-                 if we are looking at one. */
-              if (**mangled != 'F')
-                 expect_func = 1;
-	    }
-	  oldmangled = NULL;
-	  break;
-
-	case 'B':
-	  {
-	    string s;
-	    success = do_type (work, mangled, &s);
-	    if (success)
-	      {
-		string_append (&s, SCOPE_STRING (work));
-		string_prepends (declp, &s);
-		string_delete (&s);
-	      }
-	    oldmangled = NULL;
-	    expect_func = 1;
-	  }
-	  break;
-
-	case 'F':
-	  /* Function */
-	  /* ARM/HP style demangling includes a specific 'F' character after
-	     the class name.  For GNU style, it is just implied.  So we can
-	     safely just consume any 'F' at this point and be compatible
-	     with either style.  */
-
-	  oldmangled = NULL;
-	  func_done = 1;
-	  (*mangled)++;
-
-	  /* For lucid/ARM/HP style we have to forget any types we might
-	     have remembered up to this point, since they were not argument
-	     types.  GNU style considers all types seen as available for
-	     back references.  See comment in demangle_args() */
-
-	  if (LUCID_DEMANGLING || ARM_DEMANGLING || HP_DEMANGLING || EDG_DEMANGLING)
-	    {
-	      forget_types (work);
-	    }
-	  success = demangle_args (work, mangled, declp);
-	  /* After picking off the function args, we expect to either
-	     find the function return type (preceded by an '_') or the
-	     end of the string. */
-	  if (success && (AUTO_DEMANGLING || EDG_DEMANGLING) && **mangled == '_')
-	    {
-	      ++(*mangled);
-              /* At this level, we do not care about the return type. */
-              success = do_type (work, mangled, &tname);
-              string_delete (&tname);
-            }
-
-	  break;
-
-	case 't':
-	  /* G++ Template */
-	  string_init(&trawname);
-	  string_init(&tname);
-	  if (oldmangled == NULL)
-	    {
-	      oldmangled = *mangled;
-	    }
-	  success = demangle_template (work, mangled, &tname,
-				       &trawname, 1, 1);
-	  if (success)
-	    {
-	      remember_type (work, oldmangled, *mangled - oldmangled);
-	    }
-	  string_append (&tname, SCOPE_STRING (work));
-
-	  string_prepends(declp, &tname);
-	  if (work -> destructor & 1)
-	    {
-	      string_prepend (&trawname, "~");
-	      string_appends (declp, &trawname);
-	      work->destructor -= 1;
-	    }
-	  if ((work->constructor & 1) || (work->destructor & 1))
-	    {
-	      string_appends (declp, &trawname);
-	      work->constructor -= 1;
-	    }
-	  string_delete(&trawname);
-	  string_delete(&tname);
-	  oldmangled = NULL;
-	  expect_func = 1;
-	  break;
-
-	case '_':
-	  if ((AUTO_DEMANGLING || GNU_DEMANGLING) && expect_return_type)
-	    {
-	      /* Read the return type. */
-	      string return_type;
-
-	      (*mangled)++;
-	      success = do_type (work, mangled, &return_type);
-	      APPEND_BLANK (&return_type);
-
-	      string_prepends (declp, &return_type);
-	      string_delete (&return_type);
-	      break;
-	    }
-	  else
-	    /* At the outermost level, we cannot have a return type specified,
-	       so if we run into another '_' at this point we are dealing with
-	       a mangled name that is either bogus, or has been mangled by
-	       some algorithm we don't know how to deal with.  So just
-	       reject the entire demangling.  */
-            /* However, "_nnn" is an expected suffix for alternate entry point
-               numbered nnn for a function, with HP aCC, so skip over that
-               without reporting failure. pai/1997-09-04 */
-            if (HP_DEMANGLING)
-              {
-                (*mangled)++;
-                while (**mangled && ISDIGIT ((unsigned char)**mangled))
-                  (*mangled)++;
-              }
-            else
-	      success = 0;
-	  break;
-
-	case 'H':
-	  if (AUTO_DEMANGLING || GNU_DEMANGLING)
-	    {
-	      /* A G++ template function.  Read the template arguments. */
-	      success = demangle_template (work, mangled, declp, 0, 0,
-					   0);
-	      if (!(work->constructor & 1))
-		expect_return_type = 1;
-	      if (!**mangled)
-		success = 0;
-	      else
-	        (*mangled)++;
-	      break;
-	    }
-	  /* fall through */
-
-	default:
-	  if (AUTO_DEMANGLING || GNU_DEMANGLING)
-	    {
-	      /* Assume we have stumbled onto the first outermost function
-		 argument token, and start processing args.  */
-	      func_done = 1;
-	      success = demangle_args (work, mangled, declp);
-	    }
-	  else
-	    {
-	      /* Non-GNU demanglers use a specific token to mark the start
-		 of the outermost function argument tokens.  Typically 'F',
-		 for ARM/HP-demangling, for example.  So if we find something
-		 we are not prepared for, it must be an error.  */
-	      success = 0;
-	    }
-	  break;
-	}
-      /*
-	if (AUTO_DEMANGLING || GNU_DEMANGLING)
-	*/
-      {
-	if (success && expect_func)
-	  {
-	    func_done = 1;
-              if (LUCID_DEMANGLING || ARM_DEMANGLING || EDG_DEMANGLING)
-                {
-                  forget_types (work);
-                }
-	    success = demangle_args (work, mangled, declp);
-	    /* Since template include the mangling of their return types,
-	       we must set expect_func to 0 so that we don't try do
-	       demangle more arguments the next time we get here.  */
-	    expect_func = 0;
-	  }
-      }
-    }
-  if (success && !func_done)
-    {
-      if (AUTO_DEMANGLING || GNU_DEMANGLING)
-	{
-	  /* With GNU style demangling, bar__3foo is 'foo::bar(void)', and
-	     bar__3fooi is 'foo::bar(int)'.  We get here when we find the
-	     first case, and need to ensure that the '(void)' gets added to
-	     the current declp.  Note that with ARM/HP, the first case
-	     represents the name of a static data member 'foo::bar',
-	     which is in the current declp, so we leave it alone.  */
-	  success = demangle_args (work, mangled, declp);
-	}
-    }
-  if (success && PRINT_ARG_TYPES)
-    {
-      if (work->static_type)
-	string_append (declp, " static");
-      if (work->type_quals != TYPE_UNQUALIFIED)
-	{
-	  APPEND_BLANK (declp);
-	  string_append (declp, qualifier_string (work->type_quals));
-	}
-    }
-
-  return (success);
-}
-
-#if 0
-
-static int
-demangle_method_args (struct work_stuff *work, const char **mangled,
-                      string *declp)
-{
-  int success = 0;
-
-  if (work -> static_type)
-    {
-      string_append (declp, *mangled + 1);
-      *mangled += strlen (*mangled);
-      success = 1;
-    }
-  else
-    {
-      success = demangle_args (work, mangled, declp);
-    }
-  return (success);
-}
-
-#endif
-
-static int
-demangle_template_template_parm (struct work_stuff *work,
-                                 const char **mangled, string *tname)
-{
-  int i;
-  int r;
-  int need_comma = 0;
-  int success = 1;
-  string temp;
-
-  string_append (tname, "template <");
-  /* get size of template parameter list */
-  if (get_count (mangled, &r))
-    {
-      for (i = 0; i < r; i++)
-	{
-	  if (need_comma)
-	    {
-	      string_append (tname, ", ");
-	    }
-
-	    /* Z for type parameters */
-	    if (**mangled == 'Z')
-	      {
-		(*mangled)++;
-		string_append (tname, "class");
-	      }
-	      /* z for template parameters */
-	    else if (**mangled == 'z')
-	      {
-		(*mangled)++;
-		success =
-		  demangle_template_template_parm (work, mangled, tname);
-		if (!success)
-		  {
-		    break;
-		  }
-	      }
-	    else
-	      {
-		/* temp is initialized in do_type */
-		success = do_type (work, mangled, &temp);
-		if (success)
-		  {
-		    string_appends (tname, &temp);
-		  }
-		string_delete(&temp);
-		if (!success)
-		  {
-		    break;
-		  }
-	      }
-	  need_comma = 1;
-	}
-
-    }
-  if (tname->p[-1] == '>')
-    string_append (tname, " ");
-  string_append (tname, "> class");
-  return (success);
-}
-
-static int
-demangle_expression (struct work_stuff *work, const char **mangled,
-                     string *s, type_kind_t tk)
-{
-  int need_operator = 0;
-  int success;
-
-  success = 1;
-  string_appendn (s, "(", 1);
-  (*mangled)++;
-  while (success && **mangled != 'W' && **mangled != '\0')
-    {
-      if (need_operator)
-	{
-	  size_t i;
-	  size_t len;
-
-	  success = 0;
-
-	  len = strlen (*mangled);
-
-	  for (i = 0; i < ARRAY_SIZE (optable); ++i)
-	    {
-	      size_t l = strlen (optable[i].in);
-
-	      if (l <= len
-		  && memcmp (optable[i].in, *mangled, l) == 0)
-		{
-		  string_appendn (s, " ", 1);
-		  string_append (s, optable[i].out);
-		  string_appendn (s, " ", 1);
-		  success = 1;
-		  (*mangled) += l;
-		  break;
-		}
-	    }
-
-	  if (!success)
-	    break;
-	}
-      else
-	need_operator = 1;
-
-      success = demangle_template_value_parm (work, mangled, s, tk);
-    }
-
-  if (**mangled != 'W')
-    success = 0;
-  else
-    {
-      string_appendn (s, ")", 1);
-      (*mangled)++;
-    }
-
-  return success;
-}
-
-static int
-demangle_integral_value (struct work_stuff *work,
-                         const char **mangled, string *s)
-{
-  int success;
-
-  if (**mangled == 'E')
-    success = demangle_expression (work, mangled, s, tk_integral);
-  else if (**mangled == 'Q' || **mangled == 'K')
-    success = demangle_qualified (work, mangled, s, 0, 1);
-  else
-    {
-      int value;
-
-      /* By default, we let the number decide whether we shall consume an
-	 underscore.  */
-      int multidigit_without_leading_underscore = 0;
-      int leave_following_underscore = 0;
-
-      success = 0;
-
-      if (**mangled == '_')
-        {
-	  if (mangled[0][1] == 'm')
-	    {
-	      /* Since consume_count_with_underscores does not handle the
-		 `m'-prefix we must do it here, using consume_count and
-		 adjusting underscores: we have to consume the underscore
-		 matching the prepended one.  */
-	      multidigit_without_leading_underscore = 1;
-	      string_appendn (s, "-", 1);
-	      (*mangled) += 2;
-	    }
-	  else
-	    {
-	      /* Do not consume a following underscore;
-	         consume_count_with_underscores will consume what
-	         should be consumed.  */
-	      leave_following_underscore = 1;
-	    }
-	}
-      else
-	{
-	  /* Negative numbers are indicated with a leading `m'.  */
-	  if (**mangled == 'm')
-	  {
-	    string_appendn (s, "-", 1);
-	    (*mangled)++;
-	  }
-	  /* Since consume_count_with_underscores does not handle
-	     multi-digit numbers that do not start with an underscore,
-	     and this number can be an integer template parameter,
-	     we have to call consume_count. */
-	  multidigit_without_leading_underscore = 1;
-	  /* These multi-digit numbers never end on an underscore,
-	     so if there is one then don't eat it. */
-	  leave_following_underscore = 1;
-	}
-
-      /* We must call consume_count if we expect to remove a trailing
-	 underscore, since consume_count_with_underscores expects
-	 the leading underscore (that we consumed) if it is to handle
-	 multi-digit numbers.  */
-      if (multidigit_without_leading_underscore)
-	value = consume_count (mangled);
-      else
-	value = consume_count_with_underscores (mangled);
-
-      if (value != -1)
-	{
-	  char buf[INTBUF_SIZE];
-	  sprintf (buf, "%d", value);
-	  string_append (s, buf);
-
-	  /* Numbers not otherwise delimited, might have an underscore
-	     appended as a delimeter, which we should skip.
-
-	     ??? This used to always remove a following underscore, which
-	     is wrong.  If other (arbitrary) cases are followed by an
-	     underscore, we need to do something more radical.  */
-
-	  if ((value > 9 || multidigit_without_leading_underscore)
-	      && ! leave_following_underscore
-	      && **mangled == '_')
-	    (*mangled)++;
-
-	  /* All is well.  */
-	  success = 1;
-	}
-      }
-
-  return success;
-}
-
-/* Demangle the real value in MANGLED.  */
-
-static int
-demangle_real_value (struct work_stuff *work,
-                     const char **mangled, string *s)
-{
-  if (**mangled == 'E')
-    return demangle_expression (work, mangled, s, tk_real);
-
-  if (**mangled == 'm')
-    {
-      string_appendn (s, "-", 1);
-      (*mangled)++;
-    }
-  while (ISDIGIT ((unsigned char)**mangled))
-    {
-      string_appendn (s, *mangled, 1);
-      (*mangled)++;
-    }
-  if (**mangled == '.') /* fraction */
-    {
-      string_appendn (s, ".", 1);
-      (*mangled)++;
-      while (ISDIGIT ((unsigned char)**mangled))
-	{
-	  string_appendn (s, *mangled, 1);
-	  (*mangled)++;
-	}
-    }
-  if (**mangled == 'e') /* exponent */
-    {
-      string_appendn (s, "e", 1);
-      (*mangled)++;
-      while (ISDIGIT ((unsigned char)**mangled))
-	{
-	  string_appendn (s, *mangled, 1);
-	  (*mangled)++;
-	}
-    }
-
-  return 1;
-}
-
-static int
-demangle_template_value_parm (struct work_stuff *work, const char **mangled,
-                              string *s, type_kind_t tk)
-{
-  int success = 1;
-
-  if (**mangled == 'Y')
-    {
-      /* The next argument is a template parameter. */
-      int idx;
-
-      (*mangled)++;
-      idx = consume_count_with_underscores (mangled);
-      if (idx == -1
-	  || (work->tmpl_argvec && idx >= work->ntmpl_args)
-	  || consume_count_with_underscores (mangled) == -1)
-	return -1;
-      if (work->tmpl_argvec)
-	string_append (s, work->tmpl_argvec[idx]);
-      else
-	string_append_template_idx (s, idx);
-    }
-  else if (tk == tk_integral)
-    success = demangle_integral_value (work, mangled, s);
-  else if (tk == tk_char)
-    {
-      char tmp[2];
-      int val;
-      if (**mangled == 'm')
-	{
-	  string_appendn (s, "-", 1);
-	  (*mangled)++;
-	}
-      string_appendn (s, "'", 1);
-      val = consume_count(mangled);
-      if (val <= 0)
-	success = 0;
-      else
-	{
-	  tmp[0] = (char)val;
-	  tmp[1] = '\0';
-	  string_appendn (s, &tmp[0], 1);
-	  string_appendn (s, "'", 1);
-	}
-    }
-  else if (tk == tk_bool)
-    {
-      int val = consume_count (mangled);
-      if (val == 0)
-	string_appendn (s, "false", 5);
-      else if (val == 1)
-	string_appendn (s, "true", 4);
-      else
-	success = 0;
-    }
-  else if (tk == tk_real)
-    success = demangle_real_value (work, mangled, s);
-  else if (tk == tk_pointer || tk == tk_reference
-	   || tk == tk_rvalue_reference)
-    {
-      if (**mangled == 'Q')
-	success = demangle_qualified (work, mangled, s,
-				      /*isfuncname=*/0, 
-				      /*append=*/1);
-      else
-	{
-	  int symbol_len  = consume_count (mangled);
-	  if (symbol_len == -1
-	      || symbol_len > (long) strlen (*mangled))
-	    return -1;
-	  if (symbol_len == 0)
-	    string_appendn (s, "0", 1);
-	  else
-	    {
-	      char *p = XNEWVEC (char, symbol_len + 1), *q;
-	      strncpy (p, *mangled, symbol_len);
-	      p [symbol_len] = '\0';
-	      /* We use cplus_demangle here, rather than
-		 internal_cplus_demangle, because the name of the entity
-		 mangled here does not make use of any of the squangling
-		 or type-code information we have built up thus far; it is
-		 mangled independently.  */
-	      q = cplus_demangle (p, work->options);
-	      if (tk == tk_pointer)
-		string_appendn (s, "&", 1);
-	      /* FIXME: Pointer-to-member constants should get a
-		 qualifying class name here.  */
-	      if (q)
-		{
-		  string_append (s, q);
-		  free (q);
-		}
-	      else
-		string_append (s, p);
-	      free (p);
-	    }
-	  *mangled += symbol_len;
-	}
-    }
-
-  return success;
-}
-
-/* Demangle the template name in MANGLED.  The full name of the
-   template (e.g., S<int>) is placed in TNAME.  The name without the
-   template parameters (e.g. S) is placed in TRAWNAME if TRAWNAME is
-   non-NULL.  If IS_TYPE is nonzero, this template is a type template,
-   not a function template.  If both IS_TYPE and REMEMBER are nonzero,
-   the template is remembered in the list of back-referenceable
-   types.  */
-
-static int
-demangle_template (struct work_stuff *work, const char **mangled,
-                   string *tname, string *trawname,
-                   int is_type, int remember)
-{
-  int i;
-  int r;
-  int need_comma = 0;
-  int success = 0;
-  int is_java_array = 0;
-  string temp;
-
-  (*mangled)++;
-  if (is_type)
-    {
-      /* get template name */
-      if (**mangled == 'z')
-	{
-	  int idx;
-	  (*mangled)++;
-	  if (**mangled == '\0')
-	    return (0);
-	  (*mangled)++;
-
-	  idx = consume_count_with_underscores (mangled);
-	  if (idx == -1
-	      || (work->tmpl_argvec && idx >= work->ntmpl_args)
-	      || consume_count_with_underscores (mangled) == -1)
-	    return (0);
-
-	  if (work->tmpl_argvec)
-	    {
-	      string_append (tname, work->tmpl_argvec[idx]);
-	      if (trawname)
-		string_append (trawname, work->tmpl_argvec[idx]);
-	    }
-	  else
-	    {
-	      string_append_template_idx (tname, idx);
-	      if (trawname)
-		string_append_template_idx (trawname, idx);
-	    }
-	}
-      else
-	{
-	  if ((r = consume_count (mangled)) <= 0
-	      || (int) strlen (*mangled) < r)
-	    {
-	      return (0);
-	    }
-	  is_java_array = (work -> options & DMGL_JAVA)
-	    && strncmp (*mangled, "JArray1Z", 8) == 0;
-	  if (! is_java_array)
-	    {
-	      string_appendn (tname, *mangled, r);
-	    }
-	  if (trawname)
-	    string_appendn (trawname, *mangled, r);
-	  *mangled += r;
-	}
-    }
-  if (!is_java_array)
-    string_append (tname, "<");
-  /* get size of template parameter list */
-  if (!get_count (mangled, &r))
-    {
-      return (0);
-    }
-  if (!is_type)
-    {
-      /* Create an array for saving the template argument values. */
-      work->tmpl_argvec = XNEWVEC (char *, r);
-      work->ntmpl_args = r;
-      for (i = 0; i < r; i++)
-	work->tmpl_argvec[i] = 0;
-    }
-  for (i = 0; i < r; i++)
-    {
-      if (need_comma)
-	{
-	  string_append (tname, ", ");
-	}
-      /* Z for type parameters */
-      if (**mangled == 'Z')
-	{
-	  (*mangled)++;
-	  /* temp is initialized in do_type */
-	  success = do_type (work, mangled, &temp);
-	  if (success)
-	    {
-	      string_appends (tname, &temp);
-
-	      if (!is_type)
-		{
-		  /* Save the template argument. */
-		  int len = temp.p - temp.b;
-		  work->tmpl_argvec[i] = XNEWVEC (char, len + 1);
-		  memcpy (work->tmpl_argvec[i], temp.b, len);
-		  work->tmpl_argvec[i][len] = '\0';
-		}
-	    }
-	  string_delete(&temp);
-	  if (!success)
-	    {
-	      break;
-	    }
-	}
-      /* z for template parameters */
-      else if (**mangled == 'z')
-	{
-	  int r2;
-	  (*mangled)++;
-	  success = demangle_template_template_parm (work, mangled, tname);
-
-	  if (success
-	      && (r2 = consume_count (mangled)) > 0
-	      && (int) strlen (*mangled) >= r2)
-	    {
-	      string_append (tname, " ");
-	      string_appendn (tname, *mangled, r2);
-	      if (!is_type)
-		{
-		  /* Save the template argument. */
-		  int len = r2;
-		  work->tmpl_argvec[i] = XNEWVEC (char, len + 1);
-		  memcpy (work->tmpl_argvec[i], *mangled, len);
-		  work->tmpl_argvec[i][len] = '\0';
-		}
-	      *mangled += r2;
-	    }
-	  if (!success)
-	    {
-	      break;
-	    }
-	}
-      else
-	{
-	  string  param;
-	  string* s;
-
-	  /* otherwise, value parameter */
-
-	  /* temp is initialized in do_type */
-	  success = do_type (work, mangled, &temp);
-	  string_delete(&temp);
-	  if (!success)
-	    break;
-
-	  if (!is_type)
-	    {
-	      s = &param;
-	      string_init (s);
-	    }
-	  else
-	    s = tname;
-
-	  success = demangle_template_value_parm (work, mangled, s,
-						  (type_kind_t) success);
-
-	  if (!success)
-	    {
-	      if (!is_type)
-		string_delete (s);
-	      success = 0;
-	      break;
-	    }
-
-	  if (!is_type)
-	    {
-	      int len = s->p - s->b;
-	      work->tmpl_argvec[i] = XNEWVEC (char, len + 1);
-	      memcpy (work->tmpl_argvec[i], s->b, len);
-	      work->tmpl_argvec[i][len] = '\0';
-
-	      string_appends (tname, s);
-	      string_delete (s);
-	    }
-	}
-      need_comma = 1;
-    }
-  if (is_java_array)
-    {
-      string_append (tname, "[]");
-    }
-  else
-    {
-      if (tname->p[-1] == '>')
-	string_append (tname, " ");
-      string_append (tname, ">");
-    }
-
-  if (is_type && remember)
-    {
-      const int bindex = register_Btype (work);
-      remember_Btype (work, tname->b, LEN_STRING (tname), bindex);
-    }
-
-  /*
-    if (work -> static_type)
-    {
-    string_append (declp, *mangled + 1);
-    *mangled += strlen (*mangled);
-    success = 1;
-    }
-    else
-    {
-    success = demangle_args (work, mangled, declp);
-    }
-    }
-    */
-  return (success);
-}
-
-static int
-arm_pt (struct work_stuff *work, const char *mangled,
-        int n, const char **anchor, const char **args)
-{
-  /* Check if ARM template with "__pt__" in it ("parameterized type") */
-  /* Allow HP also here, because HP's cfront compiler follows ARM to some extent */
-  if ((ARM_DEMANGLING || HP_DEMANGLING) && (*anchor = strstr (mangled, "__pt__")))
-    {
-      int len;
-      *args = *anchor + 6;
-      len = consume_count (args);
-      if (len == -1)
-	return 0;
-      if (*args + len == mangled + n && **args == '_')
-	{
-	  ++*args;
-	  return 1;
-	}
-    }
-  if (AUTO_DEMANGLING || EDG_DEMANGLING)
-    {
-      if ((*anchor = strstr (mangled, "__tm__"))
-          || (*anchor = strstr (mangled, "__ps__"))
-          || (*anchor = strstr (mangled, "__pt__")))
-        {
-          int len;
-          *args = *anchor + 6;
-          len = consume_count (args);
-	  if (len == -1)
-	    return 0;
-          if (*args + len == mangled + n && **args == '_')
-            {
-              ++*args;
-              return 1;
-            }
-        }
-      else if ((*anchor = strstr (mangled, "__S")))
-        {
- 	  int len;
- 	  *args = *anchor + 3;
- 	  len = consume_count (args);
-	  if (len == -1)
-	    return 0;
- 	  if (*args + len == mangled + n && **args == '_')
-            {
-              ++*args;
- 	      return 1;
-            }
-        }
-    }
-
-  return 0;
-}
-
-static void
-demangle_arm_hp_template (struct work_stuff *work, const char **mangled,
-                          int n, string *declp)
-{
-  const char *p;
-  const char *args;
-  const char *e = *mangled + n;
-  string arg;
-
-  /* Check for HP aCC template spec: classXt1t2 where t1, t2 are
-     template args */
-  if (HP_DEMANGLING && ((*mangled)[n] == 'X'))
-    {
-      char *start_spec_args = NULL;
-      int hold_options;
-
-      /* First check for and omit template specialization pseudo-arguments,
-         such as in "Spec<#1,#1.*>" */
-      start_spec_args = strchr (*mangled, '<');
-      if (start_spec_args && (start_spec_args - *mangled < n))
-        string_appendn (declp, *mangled, start_spec_args - *mangled);
-      else
-        string_appendn (declp, *mangled, n);
-      (*mangled) += n + 1;
-      string_init (&arg);
-      if (work->temp_start == -1) /* non-recursive call */
-        work->temp_start = declp->p - declp->b;
-
-      /* We want to unconditionally demangle parameter types in
-	 template parameters.  */
-      hold_options = work->options;
-      work->options |= DMGL_PARAMS;
-
-      string_append (declp, "<");
-      while (1)
-        {
-          string_delete (&arg);
-          switch (**mangled)
-            {
-              case 'T':
-                /* 'T' signals a type parameter */
-                (*mangled)++;
-                if (!do_type (work, mangled, &arg))
-                  goto hpacc_template_args_done;
-                break;
-
-              case 'U':
-              case 'S':
-                /* 'U' or 'S' signals an integral value */
-                if (!do_hpacc_template_const_value (work, mangled, &arg))
-                  goto hpacc_template_args_done;
-                break;
-
-              case 'A':
-                /* 'A' signals a named constant expression (literal) */
-                if (!do_hpacc_template_literal (work, mangled, &arg))
-                  goto hpacc_template_args_done;
-                break;
-
-              default:
-                /* Today, 1997-09-03, we have only the above types
-                   of template parameters */
-                /* FIXME: maybe this should fail and return null */
-                goto hpacc_template_args_done;
-            }
-          string_appends (declp, &arg);
-         /* Check if we're at the end of template args.
-             0 if at end of static member of template class,
-             _ if done with template args for a function */
-          if ((**mangled == '\000') || (**mangled == '_'))
-            break;
-          else
-            string_append (declp, ",");
-        }
-    hpacc_template_args_done:
-      string_append (declp, ">");
-      string_delete (&arg);
-      if (**mangled == '_')
-        (*mangled)++;
-      work->options = hold_options;
-      return;
-    }
-  /* ARM template? (Also handles HP cfront extensions) */
-  else if (arm_pt (work, *mangled, n, &p, &args))
-    {
-      int hold_options;
-      string type_str;
-
-      string_init (&arg);
-      string_appendn (declp, *mangled, p - *mangled);
-      if (work->temp_start == -1)  /* non-recursive call */
-	work->temp_start = declp->p - declp->b;
-
-      /* We want to unconditionally demangle parameter types in
-	 template parameters.  */
-      hold_options = work->options;
-      work->options |= DMGL_PARAMS;
-
-      string_append (declp, "<");
-      /* should do error checking here */
-      while (args < e) {
-	string_delete (&arg);
-
-	/* Check for type or literal here */
-	switch (*args)
-	  {
-	    /* HP cfront extensions to ARM for template args */
-	    /* spec: Xt1Lv1 where t1 is a type, v1 is a literal value */
-	    /* FIXME: We handle only numeric literals for HP cfront */
-          case 'X':
-            /* A typed constant value follows */
-            args++;
-            if (!do_type (work, &args, &type_str))
-	      goto cfront_template_args_done;
-            string_append (&arg, "(");
-            string_appends (&arg, &type_str);
-            string_delete (&type_str);
-            string_append (&arg, ")");
-            if (*args != 'L')
-              goto cfront_template_args_done;
-            args++;
-            /* Now snarf a literal value following 'L' */
-            if (!snarf_numeric_literal (&args, &arg))
-	      goto cfront_template_args_done;
-            break;
-
-          case 'L':
-            /* Snarf a literal following 'L' */
-            args++;
-            if (!snarf_numeric_literal (&args, &arg))
-	      goto cfront_template_args_done;
-            break;
-          default:
-            /* Not handling other HP cfront stuff */
-            {
-              const char* old_args = args;
-              if (!do_type (work, &args, &arg))
-                goto cfront_template_args_done;
-
-              /* Fail if we didn't make any progress: prevent infinite loop. */
-              if (args == old_args)
-		{
-		  work->options = hold_options;
-		  return;
-		}
-            }
-	  }
-	string_appends (declp, &arg);
-	string_append (declp, ",");
-      }
-    cfront_template_args_done:
-      string_delete (&arg);
-      if (args >= e)
-	--declp->p; /* remove extra comma */
-      string_append (declp, ">");
-      work->options = hold_options;
-    }
-  else if (n>10 && strncmp (*mangled, "_GLOBAL_", 8) == 0
-	   && (*mangled)[9] == 'N'
-	   && (*mangled)[8] == (*mangled)[10]
-	   && strchr (cplus_markers, (*mangled)[8]))
-    {
-      /* A member of the anonymous namespace.  */
-      string_append (declp, "{anonymous}");
-    }
-  else
-    {
-      if (work->temp_start == -1) /* non-recursive call only */
-	work->temp_start = 0;     /* disable in recursive calls */
-      string_appendn (declp, *mangled, n);
-    }
-  *mangled += n;
-}
-
-/* Extract a class name, possibly a template with arguments, from the
-   mangled string; qualifiers, local class indicators, etc. have
-   already been dealt with */
-
-static int
-demangle_class_name (struct work_stuff *work, const char **mangled,
-                     string *declp)
-{
-  int n;
-  int success = 0;
-
-  n = consume_count (mangled);
-  if (n == -1)
-    return 0;
-  if ((int) strlen (*mangled) >= n)
-    {
-      demangle_arm_hp_template (work, mangled, n, declp);
-      success = 1;
-    }
-
-  return (success);
-}
-
-/*
-
-LOCAL FUNCTION
-
-	demangle_class -- demangle a mangled class sequence
-
-SYNOPSIS
-
-	static int
-	demangle_class (struct work_stuff *work, const char **mangled,
-			strint *declp)
-
-DESCRIPTION
-
-	DECLP points to the buffer into which demangling is being done.
-
-	*MANGLED points to the current token to be demangled.  On input,
-	it points to a mangled class (I.E. "3foo", "13verylongclass", etc.)
-	On exit, it points to the next token after the mangled class on
-	success, or the first unconsumed token on failure.
-
-	If the CONSTRUCTOR or DESTRUCTOR flags are set in WORK, then
-	we are demangling a constructor or destructor.  In this case
-	we prepend "class::class" or "class::~class" to DECLP.
-
-	Otherwise, we prepend "class::" to the current DECLP.
-
-	Reset the constructor/destructor flags once they have been
-	"consumed".  This allows demangle_class to be called later during
-	the same demangling, to do normal class demangling.
-
-	Returns 1 if demangling is successful, 0 otherwise.
-
-*/
-
-static int
-demangle_class (struct work_stuff *work, const char **mangled, string *declp)
-{
-  int success = 0;
-  int btype;
-  string class_name;
-  char *save_class_name_end = 0;
-
-  string_init (&class_name);
-  btype = register_Btype (work);
-  if (demangle_class_name (work, mangled, &class_name))
-    {
-      save_class_name_end = class_name.p;
-      if ((work->constructor & 1) || (work->destructor & 1))
-	{
-          /* adjust so we don't include template args */
-          if (work->temp_start && (work->temp_start != -1))
-            {
-              class_name.p = class_name.b + work->temp_start;
-            }
-	  string_prepends (declp, &class_name);
-	  if (work -> destructor & 1)
-	    {
-	      string_prepend (declp, "~");
-              work -> destructor -= 1;
-	    }
-	  else
-	    {
-	      work -> constructor -= 1;
-	    }
-	}
-      class_name.p = save_class_name_end;
-      remember_Ktype (work, class_name.b, LEN_STRING(&class_name));
-      remember_Btype (work, class_name.b, LEN_STRING(&class_name), btype);
-      string_prepend (declp, SCOPE_STRING (work));
-      string_prepends (declp, &class_name);
-      success = 1;
-    }
-  string_delete (&class_name);
-  return (success);
-}
-
-
-/* Called when there's a "__" in the mangled name, with `scan' pointing to
-   the rightmost guess.
-
-   Find the correct "__"-sequence where the function name ends and the
-   signature starts, which is ambiguous with GNU mangling.
-   Call demangle_signature here, so we can make sure we found the right
-   one; *mangled will be consumed so caller will not make further calls to
-   demangle_signature.  */
-
-static int
-iterate_demangle_function (struct work_stuff *work, const char **mangled,
-                           string *declp, const char *scan)
-{
-  const char *mangle_init = *mangled;
-  int success = 0;
-  string decl_init;
-  struct work_stuff work_init;
-
-  if (*(scan + 2) == '\0')
-    return 0;
-
-  /* Do not iterate for some demangling modes, or if there's only one
-     "__"-sequence.  This is the normal case.  */
-  if (ARM_DEMANGLING || LUCID_DEMANGLING || HP_DEMANGLING || EDG_DEMANGLING
-      || strstr (scan + 2, "__") == NULL)
-    return demangle_function_name (work, mangled, declp, scan);
-
-  /* Save state so we can restart if the guess at the correct "__" was
-     wrong.  */
-  string_init (&decl_init);
-  string_appends (&decl_init, declp);
-  memset (&work_init, 0, sizeof work_init);
-  work_stuff_copy_to_from (&work_init, work);
-
-  /* Iterate over occurrences of __, allowing names and types to have a
-     "__" sequence in them.  We must start with the first (not the last)
-     occurrence, since "__" most often occur between independent mangled
-     parts, hence starting at the last occurence inside a signature
-     might get us a "successful" demangling of the signature.  */
-
-  while (scan[2])
-    {
-      if (demangle_function_name (work, mangled, declp, scan))
-	{
-	  success = demangle_signature (work, mangled, declp);
-	  if (success)
-	    break;
-	}
-
-      /* Reset demangle state for the next round.  */
-      *mangled = mangle_init;
-      string_clear (declp);
-      string_appends (declp, &decl_init);
-      work_stuff_copy_to_from (work, &work_init);
-
-      /* Leave this underscore-sequence.  */
-      scan += 2;
-
-      /* Scan for the next "__" sequence.  */
-      while (*scan && (scan[0] != '_' || scan[1] != '_'))
-	scan++;
-
-      /* Move to last "__" in this sequence.  */
-      while (*scan && *scan == '_')
-	scan++;
-      scan -= 2;
-    }
-
-  /* Delete saved state.  */
-  delete_work_stuff (&work_init);
-  string_delete (&decl_init);
-
-  return success;
-}
-
-/*
-
-LOCAL FUNCTION
-
-	demangle_prefix -- consume the mangled name prefix and find signature
-
-SYNOPSIS
-
-	static int
-	demangle_prefix (struct work_stuff *work, const char **mangled,
-			 string *declp);
-
-DESCRIPTION
-
-	Consume and demangle the prefix of the mangled name.
-	While processing the function name root, arrange to call
-	demangle_signature if the root is ambiguous.
-
-	DECLP points to the string buffer into which demangled output is
-	placed.  On entry, the buffer is empty.  On exit it contains
-	the root function name, the demangled operator name, or in some
-	special cases either nothing or the completely demangled result.
-
-	MANGLED points to the current pointer into the mangled name.  As each
-	token of the mangled name is consumed, it is updated.  Upon entry
-	the current mangled name pointer points to the first character of
-	the mangled name.  Upon exit, it should point to the first character
-	of the signature if demangling was successful, or to the first
-	unconsumed character if demangling of the prefix was unsuccessful.
-
-	Returns 1 on success, 0 otherwise.
- */
-
-static int
-demangle_prefix (struct work_stuff *work, const char **mangled,
-                 string *declp)
-{
-  int success = 1;
-  const char *scan;
-  int i;
-
-  if (strlen(*mangled) > 6
-      && (strncmp(*mangled, "_imp__", 6) == 0
-          || strncmp(*mangled, "__imp_", 6) == 0))
-    {
-      /* it's a symbol imported from a PE dynamic library. Check for both
-         new style prefix _imp__ and legacy __imp_ used by older versions
-	 of dlltool. */
-      (*mangled) += 6;
-      work->dllimported = 1;
-    }
-  else if (strlen(*mangled) >= 11 && strncmp(*mangled, "_GLOBAL_", 8) == 0)
-    {
-      char *marker = strchr (cplus_markers, (*mangled)[8]);
-      if (marker != NULL && *marker == (*mangled)[10])
-	{
-	  if ((*mangled)[9] == 'D')
-	    {
-	      /* it's a GNU global destructor to be executed at program exit */
-	      (*mangled) += 11;
-	      work->destructor = 2;
-	      if (gnu_special (work, mangled, declp))
-		return success;
-	    }
-	  else if ((*mangled)[9] == 'I')
-	    {
-	      /* it's a GNU global constructor to be executed at program init */
-	      (*mangled) += 11;
-	      work->constructor = 2;
-	      if (gnu_special (work, mangled, declp))
-		return success;
-	    }
-	}
-    }
-  else if ((ARM_DEMANGLING || HP_DEMANGLING || EDG_DEMANGLING) && strncmp(*mangled, "__std__", 7) == 0)
-    {
-      /* it's a ARM global destructor to be executed at program exit */
-      (*mangled) += 7;
-      work->destructor = 2;
-    }
-  else if ((ARM_DEMANGLING || HP_DEMANGLING || EDG_DEMANGLING) && strncmp(*mangled, "__sti__", 7) == 0)
-    {
-      /* it's a ARM global constructor to be executed at program initial */
-      (*mangled) += 7;
-      work->constructor = 2;
-    }
-
-  /*  This block of code is a reduction in strength time optimization
-      of:
-      scan = strstr (*mangled, "__"); */
-
-  {
-    scan = *mangled;
-
-    do {
-      scan = strchr (scan, '_');
-    } while (scan != NULL && *++scan != '_');
-
-    if (scan != NULL) --scan;
-  }
-
-  if (scan != NULL)
-    {
-      /* We found a sequence of two or more '_', ensure that we start at
-	 the last pair in the sequence.  */
-      i = strspn (scan, "_");
-      if (i > 2)
-	{
-	  scan += (i - 2);
-	}
-    }
-
-  if (scan == NULL)
-    {
-      success = 0;
-    }
-  else if (work -> static_type)
-    {
-      if (!ISDIGIT ((unsigned char)scan[0]) && (scan[0] != 't'))
-	{
-	  success = 0;
-	}
-    }
-  else if ((scan == *mangled)
-	   && (ISDIGIT ((unsigned char)scan[2]) || (scan[2] == 'Q')
-	       || (scan[2] == 't') || (scan[2] == 'K') || (scan[2] == 'H')))
-    {
-      /* The ARM says nothing about the mangling of local variables.
-	 But cfront mangles local variables by prepending __<nesting_level>
-	 to them. As an extension to ARM demangling we handle this case.  */
-      if ((LUCID_DEMANGLING || ARM_DEMANGLING || HP_DEMANGLING)
-	  && ISDIGIT ((unsigned char)scan[2]))
-	{
-	  *mangled = scan + 2;
-	  consume_count (mangled);
-	  string_append (declp, *mangled);
-	  *mangled += strlen (*mangled);
-	  success = 1;
-	}
-      else
-	{
-	  /* A GNU style constructor starts with __[0-9Qt].  But cfront uses
-	     names like __Q2_3foo3bar for nested type names.  So don't accept
-	     this style of constructor for cfront demangling.  A GNU
-	     style member-template constructor starts with 'H'. */
-	  if (!(LUCID_DEMANGLING || ARM_DEMANGLING || HP_DEMANGLING || EDG_DEMANGLING))
-	    work -> constructor += 1;
-	  *mangled = scan + 2;
-	}
-    }
-  else if (ARM_DEMANGLING && scan[2] == 'p' && scan[3] == 't')
-    {
-      /* Cfront-style parameterized type.  Handled later as a signature. */
-      success = 1;
-
-      /* ARM template? */
-      demangle_arm_hp_template (work, mangled, strlen (*mangled), declp);
-    }
-  else if (EDG_DEMANGLING && ((scan[2] == 't' && scan[3] == 'm')
-                              || (scan[2] == 'p' && scan[3] == 's')
-                              || (scan[2] == 'p' && scan[3] == 't')))
-    {
-      /* EDG-style parameterized type.  Handled later as a signature. */
-      success = 1;
-
-      /* EDG template? */
-      demangle_arm_hp_template (work, mangled, strlen (*mangled), declp);
-    }
-  else if ((scan == *mangled) && !ISDIGIT ((unsigned char)scan[2])
-	   && (scan[2] != 't'))
-    {
-      /* Mangled name starts with "__".  Skip over any leading '_' characters,
-	 then find the next "__" that separates the prefix from the signature.
-	 */
-      if (!(ARM_DEMANGLING || LUCID_DEMANGLING || HP_DEMANGLING || EDG_DEMANGLING)
-	  || (arm_special (mangled, declp) == 0))
-	{
-	  while (*scan == '_')
-	    {
-	      scan++;
-	    }
-	  if ((scan = strstr (scan, "__")) == NULL || (*(scan + 2) == '\0'))
-	    {
-	      /* No separator (I.E. "__not_mangled"), or empty signature
-		 (I.E. "__not_mangled_either__") */
-	      success = 0;
-	    }
-	  else
-	    return iterate_demangle_function (work, mangled, declp, scan);
-	}
-    }
-  else if (*(scan + 2) != '\0')
-    {
-      /* Mangled name does not start with "__" but does have one somewhere
-	 in there with non empty stuff after it.  Looks like a global
-	 function name.  Iterate over all "__":s until the right
-	 one is found.  */
-      return iterate_demangle_function (work, mangled, declp, scan);
-    }
-  else
-    {
-      /* Doesn't look like a mangled name */
-      success = 0;
-    }
-
-  if (!success && (work->constructor == 2 || work->destructor == 2))
-    {
-      string_append (declp, *mangled);
-      *mangled += strlen (*mangled);
-      success = 1;
-    }
-  return (success);
-}
-
-/*
-
-LOCAL FUNCTION
-
-	gnu_special -- special handling of gnu mangled strings
-
-SYNOPSIS
-
-	static int
-	gnu_special (struct work_stuff *work, const char **mangled,
-		     string *declp);
-
-
-DESCRIPTION
-
-	Process some special GNU style mangling forms that don't fit
-	the normal pattern.  For example:
-
-		_$_3foo		(destructor for class foo)
-		_vt$foo		(foo virtual table)
-		_vt$foo$bar	(foo::bar virtual table)
-		__vt_foo	(foo virtual table, new style with thunks)
-		_3foo$varname	(static data member)
-		_Q22rs2tu$vw	(static data member)
-		__t6vector1Zii	(constructor with template)
-		__thunk_4__$_7ostream (virtual function thunk)
- */
-
-static int
-gnu_special (struct work_stuff *work, const char **mangled, string *declp)
-{
-  int n;
-  int success = 1;
-  const char *p;
-
-  if ((*mangled)[0] == '_' && (*mangled)[1] != '\0'
-      && strchr (cplus_markers, (*mangled)[1]) != NULL
-      && (*mangled)[2] == '_')
-    {
-      /* Found a GNU style destructor, get past "_<CPLUS_MARKER>_" */
-      (*mangled) += 3;
-      work -> destructor += 1;
-    }
-  else if ((*mangled)[0] == '_'
-	   && (((*mangled)[1] == '_'
-		&& (*mangled)[2] == 'v'
-		&& (*mangled)[3] == 't'
-		&& (*mangled)[4] == '_')
-	       || ((*mangled)[1] == 'v'
-		   && (*mangled)[2] == 't' && (*mangled)[3] != '\0'
-		   && strchr (cplus_markers, (*mangled)[3]) != NULL)))
-    {
-      /* Found a GNU style virtual table, get past "_vt<CPLUS_MARKER>"
-         and create the decl.  Note that we consume the entire mangled
-	 input string, which means that demangle_signature has no work
-	 to do.  */
-      if ((*mangled)[2] == 'v')
-	(*mangled) += 5; /* New style, with thunks: "__vt_" */
-      else
-	(*mangled) += 4; /* Old style, no thunks: "_vt<CPLUS_MARKER>" */
-      while (**mangled != '\0')
-	{
-	  switch (**mangled)
-	    {
-	    case 'Q':
-	    case 'K':
-	      success = demangle_qualified (work, mangled, declp, 0, 1);
-	      break;
-	    case 't':
-	      success = demangle_template (work, mangled, declp, 0, 1,
-					   1);
-	      break;
-	    default:
-	      if (ISDIGIT((unsigned char)*mangled[0]))
-		{
-		  n = consume_count(mangled);
-		  /* We may be seeing a too-large size, or else a
-		     ".<digits>" indicating a static local symbol.  In
-		     any case, declare victory and move on; *don't* try
-		     to use n to allocate.  */
-		  if (n > (int) strlen (*mangled))
-		    {
-		      success = 1;
-		      break;
-		    }
-		  else if (n == -1)
-		    {
-		      success = 0;
-		      break;
-		    }
-		}
-	      else
-		{
-		  n = strcspn (*mangled, cplus_markers);
-		}
-	      string_appendn (declp, *mangled, n);
-	      (*mangled) += n;
-	    }
-
-	  p = strpbrk (*mangled, cplus_markers);
-	  if (success && ((p == NULL) || (p == *mangled)))
-	    {
-	      if (p != NULL)
-		{
-		  string_append (declp, SCOPE_STRING (work));
-		  (*mangled)++;
-		}
-	    }
-	  else
-	    {
-	      success = 0;
-	      break;
-	    }
-	}
-      if (success)
-	string_append (declp, " virtual table");
-    }
-  else if ((*mangled)[0] == '_'
-	   && (strchr("0123456789Qt", (*mangled)[1]) != NULL)
-	   && (p = strpbrk (*mangled, cplus_markers)) != NULL)
-    {
-      /* static data member, "_3foo$varname" for example */
-      (*mangled)++;
-      switch (**mangled)
-	{
-	case 'Q':
-	case 'K':
-	  success = demangle_qualified (work, mangled, declp, 0, 1);
-	  break;
-	case 't':
-	  success = demangle_template (work, mangled, declp, 0, 1, 1);
-	  break;
-	default:
-	  n = consume_count (mangled);
-	  if (n < 0 || n > (long) strlen (*mangled))
-	    {
-	      success = 0;
-	      break;
-	    }
-
-	  if (n > 10 && strncmp (*mangled, "_GLOBAL_", 8) == 0
-	      && (*mangled)[9] == 'N'
-	      && (*mangled)[8] == (*mangled)[10]
-	      && strchr (cplus_markers, (*mangled)[8]))
-	    {
-	      /* A member of the anonymous namespace.  There's information
-		 about what identifier or filename it was keyed to, but
-		 it's just there to make the mangled name unique; we just
-		 step over it.  */
-	      string_append (declp, "{anonymous}");
-	      (*mangled) += n;
-
-	      /* Now p points to the marker before the N, so we need to
-		 update it to the first marker after what we consumed.  */
-	      p = strpbrk (*mangled, cplus_markers);
-	      break;
-	    }
-
-	  string_appendn (declp, *mangled, n);
-	  (*mangled) += n;
-	}
-      if (success && (p == *mangled))
-	{
-	  /* Consumed everything up to the cplus_marker, append the
-	     variable name.  */
-	  (*mangled)++;
-	  string_append (declp, SCOPE_STRING (work));
-	  n = strlen (*mangled);
-	  string_appendn (declp, *mangled, n);
-	  (*mangled) += n;
-	}
-      else
-	{
-	  success = 0;
-	}
-    }
-  else if (strncmp (*mangled, "__thunk_", 8) == 0)
-    {
-      int delta;
-
-      (*mangled) += 8;
-      delta = consume_count (mangled);
-      if (delta == -1)
-	success = 0;
-      else if (**mangled != '_')
-        success = 0;
-      else
-	{
-	  char *method = internal_cplus_demangle (work, ++*mangled);
-
-	  if (method)
-	    {
-	      char buf[50];
-	      sprintf (buf, "virtual function thunk (delta:%d) for ", -delta);
-	      string_append (declp, buf);
-	      string_append (declp, method);
-	      free (method);
-	      n = strlen (*mangled);
-	      (*mangled) += n;
-	    }
-	  else
-	    {
-	      success = 0;
-	    }
-	}
-    }
-  else if (strncmp (*mangled, "__t", 3) == 0
-	   && ((*mangled)[3] == 'i' || (*mangled)[3] == 'f'))
-    {
-      p = (*mangled)[3] == 'i' ? " type_info node" : " type_info function";
-      (*mangled) += 4;
-      switch (**mangled)
-	{
-	case 'Q':
-	case 'K':
-	  success = demangle_qualified (work, mangled, declp, 0, 1);
-	  break;
-	case 't':
-	  success = demangle_template (work, mangled, declp, 0, 1, 1);
-	  break;
-	default:
-	  success = do_type (work, mangled, declp);
-	  break;
-	}
-      if (success && **mangled != '\0')
-	success = 0;
-      if (success)
-	string_append (declp, p);
-    }
-  else
-    {
-      success = 0;
-    }
-  return (success);
-}
-
-static void
-recursively_demangle(struct work_stuff *work, const char **mangled,
-                     string *result, int namelength)
-{
-  char * recurse = (char *)NULL;
-  char * recurse_dem = (char *)NULL;
-
-  recurse = XNEWVEC (char, namelength + 1);
-  memcpy (recurse, *mangled, namelength);
-  recurse[namelength] = '\000';
-
-  recurse_dem = cplus_demangle (recurse, work->options);
-
-  if (recurse_dem)
-    {
-      string_append (result, recurse_dem);
-      free (recurse_dem);
-    }
-  else
-    {
-      string_appendn (result, *mangled, namelength);
-    }
-  free (recurse);
-  *mangled += namelength;
-}
-
-/*
-
-LOCAL FUNCTION
-
-	arm_special -- special handling of ARM/lucid mangled strings
-
-SYNOPSIS
-
-	static int
-	arm_special (const char **mangled,
-		     string *declp);
-
-
-DESCRIPTION
-
-	Process some special ARM style mangling forms that don't fit
-	the normal pattern.  For example:
-
-		__vtbl__3foo		(foo virtual table)
-		__vtbl__3foo__3bar	(bar::foo virtual table)
-
- */
-
-static int
-arm_special (const char **mangled, string *declp)
-{
-  int n;
-  int success = 1;
-  const char *scan;
-
-  if (strncmp (*mangled, ARM_VTABLE_STRING, ARM_VTABLE_STRLEN) == 0)
-    {
-      /* Found a ARM style virtual table, get past ARM_VTABLE_STRING
-         and create the decl.  Note that we consume the entire mangled
-	 input string, which means that demangle_signature has no work
-	 to do.  */
-      scan = *mangled + ARM_VTABLE_STRLEN;
-      while (*scan != '\0')        /* first check it can be demangled */
-        {
-          n = consume_count (&scan);
-          if (n == -1)
-	    {
-	      return (0);           /* no good */
-	    }
-          scan += n;
-          if (scan[0] == '_' && scan[1] == '_')
-	    {
-	      scan += 2;
-	    }
-        }
-      (*mangled) += ARM_VTABLE_STRLEN;
-      while (**mangled != '\0')
-	{
-	  n = consume_count (mangled);
-          if (n == -1
-	      || n > (long) strlen (*mangled))
-	    return 0;
-	  string_prependn (declp, *mangled, n);
-	  (*mangled) += n;
-	  if ((*mangled)[0] == '_' && (*mangled)[1] == '_')
-	    {
-	      string_prepend (declp, "::");
-	      (*mangled) += 2;
-	    }
-	}
-      string_append (declp, " virtual table");
-    }
-  else
-    {
-      success = 0;
-    }
-  return (success);
-}
-
-/*
-
-LOCAL FUNCTION
-
-	demangle_qualified -- demangle 'Q' qualified name strings
-
-SYNOPSIS
-
-	static int
-	demangle_qualified (struct work_stuff *, const char *mangled,
-			    string *result, int isfuncname, int append);
-
-DESCRIPTION
-
-	Demangle a qualified name, such as "Q25Outer5Inner" which is
-	the mangled form of "Outer::Inner".  The demangled output is
-	prepended or appended to the result string according to the
-	state of the append flag.
-
-	If isfuncname is nonzero, then the qualified name we are building
-	is going to be used as a member function name, so if it is a
-	constructor or destructor function, append an appropriate
-	constructor or destructor name.  I.E. for the above example,
-	the result for use as a constructor is "Outer::Inner::Inner"
-	and the result for use as a destructor is "Outer::Inner::~Inner".
-
-BUGS
-
-	Numeric conversion is ASCII dependent (FIXME).
-
- */
-
-static int
-demangle_qualified (struct work_stuff *work, const char **mangled,
-                    string *result, int isfuncname, int append)
-{
-  int qualifiers = 0;
-  int success = 1;
-  char num[2];
-  string temp;
-  string last_name;
-  int bindex = register_Btype (work);
-
-  /* We only make use of ISFUNCNAME if the entity is a constructor or
-     destructor.  */
-  isfuncname = (isfuncname
-		&& ((work->constructor & 1) || (work->destructor & 1)));
-
-  string_init (&temp);
-  string_init (&last_name);
-
-  if ((*mangled)[0] == 'K')
-    {
-    /* Squangling qualified name reuse */
-      int idx;
-      (*mangled)++;
-      idx = consume_count_with_underscores (mangled);
-      if (idx == -1 || idx >= work -> numk)
-        success = 0;
-      else
-        string_append (&temp, work -> ktypevec[idx]);
-    }
-  else
-    switch ((*mangled)[1])
-    {
-    case '_':
-      /* GNU mangled name with more than 9 classes.  The count is preceded
-	 by an underscore (to distinguish it from the <= 9 case) and followed
-	 by an underscore.  */
-      (*mangled)++;
-      qualifiers = consume_count_with_underscores (mangled);
-      if (qualifiers == -1)
-	success = 0;
-      break;
-
-    case '1':
-    case '2':
-    case '3':
-    case '4':
-    case '5':
-    case '6':
-    case '7':
-    case '8':
-    case '9':
-      /* The count is in a single digit.  */
-      num[0] = (*mangled)[1];
-      num[1] = '\0';
-      qualifiers = atoi (num);
-
-      /* If there is an underscore after the digit, skip it.  This is
-	 said to be for ARM-qualified names, but the ARM makes no
-	 mention of such an underscore.  Perhaps cfront uses one.  */
-      if ((*mangled)[2] == '_')
-	{
-	  (*mangled)++;
-	}
-      (*mangled) += 2;
-      break;
-
-    case '0':
-    default:
-      success = 0;
-    }
-
-  if (!success)
-    return success;
-
-  /* Pick off the names and collect them in the temp buffer in the order
-     in which they are found, separated by '::'.  */
-
-  while (qualifiers-- > 0)
-    {
-      int remember_K = 1;
-      string_clear (&last_name);
-
-      if (*mangled[0] == '_')
-	(*mangled)++;
-
-      if (*mangled[0] == 't')
-	{
-	  /* Here we always append to TEMP since we will want to use
-	     the template name without the template parameters as a
-	     constructor or destructor name.  The appropriate
-	     (parameter-less) value is returned by demangle_template
-	     in LAST_NAME.  We do not remember the template type here,
-	     in order to match the G++ mangling algorithm.  */
-	  success = demangle_template(work, mangled, &temp,
-				      &last_name, 1, 0);
-	  if (!success)
-	    break;
-	}
-      else if (*mangled[0] == 'K')
-	{
-          int idx;
-          (*mangled)++;
-          idx = consume_count_with_underscores (mangled);
-          if (idx == -1 || idx >= work->numk)
-            success = 0;
-          else
-            string_append (&temp, work->ktypevec[idx]);
-          remember_K = 0;
-
-	  if (!success) break;
-	}
-      else
-	{
-	  if (EDG_DEMANGLING)
-            {
-	      int namelength;
- 	      /* Now recursively demangle the qualifier
- 	       * This is necessary to deal with templates in
- 	       * mangling styles like EDG */
-	      namelength = consume_count (mangled);
-	      if (namelength == -1)
-		{
-		  success = 0;
-		  break;
-		}
- 	      recursively_demangle(work, mangled, &temp, namelength);
-            }
-          else
-            {
-              string_delete (&last_name);
-              success = do_type (work, mangled, &last_name);
-              if (!success)
-                break;
-              string_appends (&temp, &last_name);
-            }
-	}
-
-      if (remember_K)
-	remember_Ktype (work, temp.b, LEN_STRING (&temp));
-
-      if (qualifiers > 0)
-	string_append (&temp, SCOPE_STRING (work));
-    }
-
-  remember_Btype (work, temp.b, LEN_STRING (&temp), bindex);
-
-  /* If we are using the result as a function name, we need to append
-     the appropriate '::' separated constructor or destructor name.
-     We do this here because this is the most convenient place, where
-     we already have a pointer to the name and the length of the name.  */
-
-  if (isfuncname)
-    {
-      string_append (&temp, SCOPE_STRING (work));
-      if (work -> destructor & 1)
-	string_append (&temp, "~");
-      string_appends (&temp, &last_name);
-    }
-
-  /* Now either prepend the temp buffer to the result, or append it,
-     depending upon the state of the append flag.  */
-
-  if (append)
-    string_appends (result, &temp);
-  else
-    {
-      if (!STRING_EMPTY (result))
-	string_append (&temp, SCOPE_STRING (work));
-      string_prepends (result, &temp);
-    }
-
-  string_delete (&last_name);
-  string_delete (&temp);
-  return (success);
-}
-
-/*
-
-LOCAL FUNCTION
-
-	get_count -- convert an ascii count to integer, consuming tokens
-
-SYNOPSIS
-
-	static int
-	get_count (const char **type, int *count)
-
-DESCRIPTION
-
-	Assume that *type points at a count in a mangled name; set
-	*count to its value, and set *type to the next character after
-	the count.  There are some weird rules in effect here.
-
-	If *type does not point at a string of digits, return zero.
-
-	If *type points at a string of digits followed by an
-	underscore, set *count to their value as an integer, advance
-	*type to point *after the underscore, and return 1.
-
-	If *type points at a string of digits not followed by an
-	underscore, consume only the first digit.  Set *count to its
-	value as an integer, leave *type pointing after that digit,
-	and return 1.
-
-        The excuse for this odd behavior: in the ARM and HP demangling
-        styles, a type can be followed by a repeat count of the form
-        `Nxy', where:
-
-        `x' is a single digit specifying how many additional copies
-            of the type to append to the argument list, and
-
-        `y' is one or more digits, specifying the zero-based index of
-            the first repeated argument in the list.  Yes, as you're
-            unmangling the name you can figure this out yourself, but
-            it's there anyway.
-
-        So, for example, in `bar__3fooFPiN51', the first argument is a
-        pointer to an integer (`Pi'), and then the next five arguments
-        are the same (`N5'), and the first repeat is the function's
-        second argument (`1').
-*/
-
-static int
-get_count (const char **type, int *count)
-{
-  const char *p;
-  int n;
-
-  if (!ISDIGIT ((unsigned char)**type))
-    return (0);
-  else
-    {
-      *count = **type - '0';
-      (*type)++;
-      if (ISDIGIT ((unsigned char)**type))
-	{
-	  p = *type;
-	  n = *count;
-	  do
-	    {
-	      n *= 10;
-	      n += *p - '0';
-	      p++;
-	    }
-	  while (ISDIGIT ((unsigned char)*p));
-	  if (*p == '_')
-	    {
-	      *type = p + 1;
-	      *count = n;
-	    }
-	}
-    }
-  return (1);
-}
-
-/* RESULT will be initialised here; it will be freed on failure.  The
-   value returned is really a type_kind_t.  */
-
-static int
-do_type (struct work_stuff *work, const char **mangled, string *result)
-{
-  int n;
-  int i;
-  int is_proctypevec;
-  int done;
-  int success;
-  string decl;
-  const char *remembered_type;
-  int type_quals;
-  type_kind_t tk = tk_none;
-
-  string_init (&decl);
-  string_init (result);
-
-  done = 0;
-  success = 1;
-  is_proctypevec = 0;
-  while (success && !done)
-    {
-      int member;
-      switch (**mangled)
-	{
-
-	  /* A pointer type */
-	case 'P':
-	case 'p':
-	  (*mangled)++;
-	  if (! (work -> options & DMGL_JAVA))
-	    string_prepend (&decl, "*");
-	  if (tk == tk_none)
-	    tk = tk_pointer;
-	  break;
-
-	  /* A reference type */
-	case 'R':
-	  (*mangled)++;
-	  string_prepend (&decl, "&");
-	  if (tk == tk_none)
-	    tk = tk_reference;
-	  break;
-
-	  /* An rvalue reference type */
-	case 'O':
-	  (*mangled)++;
-	  string_prepend (&decl, "&&");
-	  if (tk == tk_none)
-	    tk = tk_rvalue_reference;
-	  break;
-
-	  /* An array */
-	case 'A':
-	  {
-	    ++(*mangled);
-	    if (!STRING_EMPTY (&decl)
-		&& (decl.b[0] == '*' || decl.b[0] == '&'))
-	      {
-		string_prepend (&decl, "(");
-		string_append (&decl, ")");
-	      }
-	    string_append (&decl, "[");
-	    if (**mangled != '_')
-	      success = demangle_template_value_parm (work, mangled, &decl,
-						      tk_integral);
-	    if (**mangled == '_')
-	      ++(*mangled);
-	    string_append (&decl, "]");
-	    break;
-	  }
-
-	/* A back reference to a previously seen type */
-	case 'T':
-	  (*mangled)++;
-	  if (!get_count (mangled, &n) || n < 0 || n >= work -> ntypes)
-	    {
-	      success = 0;
-	    }
-	  else
-	    for (i = 0; i < work->nproctypes; i++)
-	      if (work -> proctypevec [i] == n)
-	        success = 0;
-
-	  if (success)
-	    {    
-	      is_proctypevec = 1;
-	      push_processed_type (work, n);
-	      remembered_type = work->typevec[n];
-	      mangled = &remembered_type;
-	    }
-	  break;
-
-	  /* A function */
-	case 'F':
-	  (*mangled)++;
-	    if (!STRING_EMPTY (&decl)
-		&& (decl.b[0] == '*' || decl.b[0] == '&'))
-	    {
-	      string_prepend (&decl, "(");
-	      string_append (&decl, ")");
-	    }
-	  /* After picking off the function args, we expect to either find the
-	     function return type (preceded by an '_') or the end of the
-	     string.  */
-	  if (!demangle_nested_args (work, mangled, &decl)
-	      || (**mangled != '_' && **mangled != '\0'))
-	    {
-	      success = 0;
-	      break;
-	    }
-	  if (success && (**mangled == '_'))
-	    (*mangled)++;
-	  break;
-
-	case 'M':
-	  {
-	    type_quals = TYPE_UNQUALIFIED;
-
-	    member = **mangled == 'M';
-	    (*mangled)++;
-
-	    string_append (&decl, ")");
-
-	    /* We don't need to prepend `::' for a qualified name;
-	       demangle_qualified will do that for us.  */
-	    if (**mangled != 'Q')
-	      string_prepend (&decl, SCOPE_STRING (work));
-
-	    if (ISDIGIT ((unsigned char)**mangled))
-	      {
-		n = consume_count (mangled);
-		if (n == -1
-		    || (int) strlen (*mangled) < n)
-		  {
-		    success = 0;
-		    break;
-		  }
-		string_prependn (&decl, *mangled, n);
-		*mangled += n;
-	      }
-	    else if (**mangled == 'X' || **mangled == 'Y')
-	      {
-		string temp;
-		do_type (work, mangled, &temp);
-		string_prepends (&decl, &temp);
-		string_delete (&temp);
-	      }
-	    else if (**mangled == 't')
-	      {
-		string temp;
-		string_init (&temp);
-		success = demangle_template (work, mangled, &temp,
-					     NULL, 1, 1);
-		if (success)
-		  {
-		    string_prependn (&decl, temp.b, temp.p - temp.b);
-		    string_delete (&temp);
-		  }
-		else
-		  {
-		    string_delete (&temp);
-		    break;
-		  }
-	      }
-	    else if (**mangled == 'Q')
-	      {
-		success = demangle_qualified (work, mangled, &decl,
-					      /*isfuncnam=*/0, 
-					      /*append=*/0);
-		if (!success)
-		  break;
-	      }
-	    else
-	      {
-		success = 0;
-		break;
-	      }
-
-	    string_prepend (&decl, "(");
-	    if (member)
-	      {
-		switch (**mangled)
-		  {
-		  case 'C':
-		  case 'V':
-		  case 'u':
-		    type_quals |= code_for_qualifier (**mangled);
-		    (*mangled)++;
-		    break;
-
-		  default:
-		    break;
-		  }
-
-		if (*(*mangled) != 'F')
-		  {
-		    success = 0;
-		    break;
-		  }
-		(*mangled)++;
-	      }
-	    if ((member && !demangle_nested_args (work, mangled, &decl))
-		|| **mangled != '_')
-	      {
-		success = 0;
-		break;
-	      }
-	    (*mangled)++;
-	    if (! PRINT_ANSI_QUALIFIERS)
-	      {
-		break;
-	      }
-	    if (type_quals != TYPE_UNQUALIFIED)
-	      {
-		APPEND_BLANK (&decl);
-		string_append (&decl, qualifier_string (type_quals));
-	      }
-	    break;
-	  }
-        case 'G':
-	  (*mangled)++;
-	  break;
-
-	case 'C':
-	case 'V':
-	case 'u':
-	  if (PRINT_ANSI_QUALIFIERS)
-	    {
-	      if (!STRING_EMPTY (&decl))
-		string_prepend (&decl, " ");
-
-	      string_prepend (&decl, demangle_qualifier (**mangled));
-	    }
-	  (*mangled)++;
-	  break;
-	  /*
-	    }
-	    */
-
-	  /* fall through */
-	default:
-	  done = 1;
-	  break;
-	}
-    }
-
-  if (success) switch (**mangled)
-    {
-      /* A qualified name, such as "Outer::Inner".  */
-    case 'Q':
-    case 'K':
-      {
-        success = demangle_qualified (work, mangled, result, 0, 1);
-        break;
-      }
-
-    /* A back reference to a previously seen squangled type */
-    case 'B':
-      (*mangled)++;
-      if (!get_count (mangled, &n) || n < 0 || n >= work -> numb)
-	success = 0;
-      else
-	string_append (result, work->btypevec[n]);
-      break;
-
-    case 'X':
-    case 'Y':
-      /* A template parm.  We substitute the corresponding argument. */
-      {
-	int idx;
-
-	(*mangled)++;
-	idx = consume_count_with_underscores (mangled);
-
-	if (idx == -1
-	    || (work->tmpl_argvec && idx >= work->ntmpl_args)
-	    || consume_count_with_underscores (mangled) == -1)
-	  {
-	    success = 0;
-	    break;
-	  }
-
-	if (work->tmpl_argvec)
-	  string_append (result, work->tmpl_argvec[idx]);
-	else
-	  string_append_template_idx (result, idx);
-
-	success = 1;
-      }
-    break;
-
-    default:
-      success = demangle_fund_type (work, mangled, result);
-      if (tk == tk_none)
-	tk = (type_kind_t) success;
-      break;
-    }
-
-  if (success)
-    {
-      if (!STRING_EMPTY (&decl))
-	{
-	  string_append (result, " ");
-	  string_appends (result, &decl);
-	}
-    }
-  else
-    string_delete (result);
-  string_delete (&decl);
-
-  if (is_proctypevec)
-    pop_processed_type (work); 
-
-  if (success)
-    /* Assume an integral type, if we're not sure.  */
-    return (int) ((tk == tk_none) ? tk_integral : tk);
-  else
-    return 0;
-}
-
-/* Given a pointer to a type string that represents a fundamental type
-   argument (int, long, unsigned int, etc) in TYPE, a pointer to the
-   string in which the demangled output is being built in RESULT, and
-   the WORK structure, decode the types and add them to the result.
-
-   For example:
-
-   	"Ci"	=>	"const int"
-	"Sl"	=>	"signed long"
-	"CUs"	=>	"const unsigned short"
-
-   The value returned is really a type_kind_t.  */
-
-static int
-demangle_fund_type (struct work_stuff *work,
-                    const char **mangled, string *result)
-{
-  int done = 0;
-  int success = 1;
-  char buf[INTBUF_SIZE + 5 /* 'int%u_t' */];
-  unsigned int dec = 0;
-  type_kind_t tk = tk_integral;
-
-  /* First pick off any type qualifiers.  There can be more than one.  */
-
-  while (!done)
-    {
-      switch (**mangled)
-	{
-	case 'C':
-	case 'V':
-	case 'u':
-	  if (PRINT_ANSI_QUALIFIERS)
-	    {
-              if (!STRING_EMPTY (result))
-                string_prepend (result, " ");
-	      string_prepend (result, demangle_qualifier (**mangled));
-	    }
-	  (*mangled)++;
-	  break;
-	case 'U':
-	  (*mangled)++;
-	  APPEND_BLANK (result);
-	  string_append (result, "unsigned");
-	  break;
-	case 'S': /* signed char only */
-	  (*mangled)++;
-	  APPEND_BLANK (result);
-	  string_append (result, "signed");
-	  break;
-	case 'J':
-	  (*mangled)++;
-	  APPEND_BLANK (result);
-	  string_append (result, "__complex");
-	  break;
-	default:
-	  done = 1;
-	  break;
-	}
-    }
-
-  /* Now pick off the fundamental type.  There can be only one.  */
-
-  switch (**mangled)
-    {
-    case '\0':
-    case '_':
-      break;
-    case 'v':
-      (*mangled)++;
-      APPEND_BLANK (result);
-      string_append (result, "void");
-      break;
-    case 'x':
-      (*mangled)++;
-      APPEND_BLANK (result);
-      string_append (result, "long long");
-      break;
-    case 'l':
-      (*mangled)++;
-      APPEND_BLANK (result);
-      string_append (result, "long");
-      break;
-    case 'i':
-      (*mangled)++;
-      APPEND_BLANK (result);
-      string_append (result, "int");
-      break;
-    case 's':
-      (*mangled)++;
-      APPEND_BLANK (result);
-      string_append (result, "short");
-      break;
-    case 'b':
-      (*mangled)++;
-      APPEND_BLANK (result);
-      string_append (result, "bool");
-      tk = tk_bool;
-      break;
-    case 'c':
-      (*mangled)++;
-      APPEND_BLANK (result);
-      string_append (result, "char");
-      tk = tk_char;
-      break;
-    case 'w':
-      (*mangled)++;
-      APPEND_BLANK (result);
-      string_append (result, "wchar_t");
-      tk = tk_char;
-      break;
-    case 'r':
-      (*mangled)++;
-      APPEND_BLANK (result);
-      string_append (result, "long double");
-      tk = tk_real;
-      break;
-    case 'd':
-      (*mangled)++;
-      APPEND_BLANK (result);
-      string_append (result, "double");
-      tk = tk_real;
-      break;
-    case 'f':
-      (*mangled)++;
-      APPEND_BLANK (result);
-      string_append (result, "float");
-      tk = tk_real;
-      break;
-    case 'G':
-      (*mangled)++;
-      if (!ISDIGIT ((unsigned char)**mangled))
-	{
-	  success = 0;
-	  break;
-	}
-      /* fall through */
-    case 'I':
-      (*mangled)++;
-      if (**mangled == '_')
-	{
-	  int i;
-	  (*mangled)++;
-	  for (i = 0;
-	       i < (long) sizeof (buf) - 1 && **mangled && **mangled != '_';
-	       (*mangled)++, i++)
-	    buf[i] = **mangled;
-	  if (**mangled != '_')
-	    {
-	      success = 0;
-	      break;
-	    }
-	  buf[i] = '\0';
-	  (*mangled)++;
-	}
-      else
-	{
-	  strncpy (buf, *mangled, 2);
-	  buf[2] = '\0';
-	  *mangled += min (strlen (*mangled), 2);
-	}
-      sscanf (buf, "%x", &dec);
-      sprintf (buf, "int%u_t", dec);
-      APPEND_BLANK (result);
-      string_append (result, buf);
-      break;
-
-      /* fall through */
-      /* An explicit type, such as "6mytype" or "7integer" */
-    case '0':
-    case '1':
-    case '2':
-    case '3':
-    case '4':
-    case '5':
-    case '6':
-    case '7':
-    case '8':
-    case '9':
-      {
-        int bindex = register_Btype (work);
-        string btype;
-        string_init (&btype);
-        if (demangle_class_name (work, mangled, &btype)) {
-          remember_Btype (work, btype.b, LEN_STRING (&btype), bindex);
-          APPEND_BLANK (result);
-          string_appends (result, &btype);
-        }
-        else
-          success = 0;
-        string_delete (&btype);
-        break;
-      }
-    case 't':
-      {
-        string btype;
-        string_init (&btype);
-        success = demangle_template (work, mangled, &btype, 0, 1, 1);
-        string_appends (result, &btype);
-        string_delete (&btype);
-        break;
-      }
-    default:
-      success = 0;
-      break;
-    }
-
-  return success ? ((int) tk) : 0;
-}
-
-
-/* Handle a template's value parameter for HP aCC (extension from ARM)
-   **mangled points to 'S' or 'U' */
-
-static int
-do_hpacc_template_const_value (struct work_stuff *work ATTRIBUTE_UNUSED,
-                               const char **mangled, string *result)
-{
-  int unsigned_const;
-
-  if (**mangled != 'U' && **mangled != 'S')
-    return 0;
-
-  unsigned_const = (**mangled == 'U');
-
-  (*mangled)++;
-
-  switch (**mangled)
-    {
-      case 'N':
-        string_append (result, "-");
-        /* fall through */
-      case 'P':
-        (*mangled)++;
-        break;
-      case 'M':
-        /* special case for -2^31 */
-        string_append (result, "-2147483648");
-        (*mangled)++;
-        return 1;
-      default:
-        return 0;
-    }
-
-  /* We have to be looking at an integer now */
-  if (!(ISDIGIT ((unsigned char)**mangled)))
-    return 0;
-
-  /* We only deal with integral values for template
-     parameters -- so it's OK to look only for digits */
-  while (ISDIGIT ((unsigned char)**mangled))
-    {
-      char_str[0] = **mangled;
-      string_append (result, char_str);
-      (*mangled)++;
-    }
-
-  if (unsigned_const)
-    string_append (result, "U");
-
-  /* FIXME? Some day we may have 64-bit (or larger :-) ) constants
-     with L or LL suffixes. pai/1997-09-03 */
-
-  return 1; /* success */
-}
-
-/* Handle a template's literal parameter for HP aCC (extension from ARM)
-   **mangled is pointing to the 'A' */
-
-static int
-do_hpacc_template_literal (struct work_stuff *work, const char **mangled,
-                           string *result)
-{
-  int literal_len = 0;
-  char * recurse;
-  char * recurse_dem;
-
-  if (**mangled != 'A')
-    return 0;
-
-  (*mangled)++;
-
-  literal_len = consume_count (mangled);
-
-  if (literal_len <= 0
-      || literal_len > (long) strlen (*mangled))
-    return 0;
-
-  /* Literal parameters are names of arrays, functions, etc.  and the
-     canonical representation uses the address operator */
-  string_append (result, "&");
-
-  /* Now recursively demangle the literal name */
-  recurse = XNEWVEC (char, literal_len + 1);
-  memcpy (recurse, *mangled, literal_len);
-  recurse[literal_len] = '\000';
-
-  recurse_dem = cplus_demangle (recurse, work->options);
-
-  if (recurse_dem)
-    {
-      string_append (result, recurse_dem);
-      free (recurse_dem);
-    }
-  else
-    {
-      string_appendn (result, *mangled, literal_len);
-    }
-  (*mangled) += literal_len;
-  free (recurse);
-
-  return 1;
-}
-
-static int
-snarf_numeric_literal (const char **args, string *arg)
-{
-  if (**args == '-')
-    {
-      char_str[0] = '-';
-      string_append (arg, char_str);
-      (*args)++;
-    }
-  else if (**args == '+')
-    (*args)++;
-
-  if (!ISDIGIT ((unsigned char)**args))
-    return 0;
-
-  while (ISDIGIT ((unsigned char)**args))
-    {
-      char_str[0] = **args;
-      string_append (arg, char_str);
-      (*args)++;
-    }
-
-  return 1;
-}
-
-/* Demangle the next argument, given by MANGLED into RESULT, which
-   *should be an uninitialized* string.  It will be initialized here,
-   and free'd should anything go wrong.  */
-
-static int
-do_arg (struct work_stuff *work, const char **mangled, string *result)
-{
-  /* Remember where we started so that we can record the type, for
-     non-squangling type remembering.  */
-  const char *start = *mangled;
-
-  string_init (result);
-
-  if (work->nrepeats > 0)
-    {
-      --work->nrepeats;
-
-      if (work->previous_argument == 0)
-	return 0;
-
-      /* We want to reissue the previous type in this argument list.  */
-      string_appends (result, work->previous_argument);
-      return 1;
-    }
-
-  if (**mangled == 'n')
-    {
-      /* A squangling-style repeat.  */
-      (*mangled)++;
-      work->nrepeats = consume_count(mangled);
-
-      if (work->nrepeats <= 0)
-	/* This was not a repeat count after all.  */
-	return 0;
-
-      if (work->nrepeats > 9)
-	{
-	  if (**mangled != '_')
-	    /* The repeat count should be followed by an '_' in this
-	       case.  */
-	    return 0;
-	  else
-	    (*mangled)++;
-	}
-
-      /* Now, the repeat is all set up.  */
-      return do_arg (work, mangled, result);
-    }
-
-  /* Save the result in WORK->previous_argument so that we can find it
-     if it's repeated.  Note that saving START is not good enough: we
-     do not want to add additional types to the back-referenceable
-     type vector when processing a repeated type.  */
-  if (work->previous_argument)
-    string_delete (work->previous_argument);
-  else
-    work->previous_argument = XNEW (string);
-
-  if (!do_type (work, mangled, work->previous_argument))
-    return 0;
-
-  string_appends (result, work->previous_argument);
-
-  remember_type (work, start, *mangled - start);
-  return 1;
-}
-
-static void
-push_processed_type (struct work_stuff *work, int typevec_index)
-{
-  if (work->nproctypes >= work->proctypevec_size)
-    {
-      if (!work->proctypevec_size)
-	{
-	  work->proctypevec_size = 4;
-	  work->proctypevec = XNEWVEC (int, work->proctypevec_size);
-	}
-      else 
-	{
-	  if (work->proctypevec_size < 16)
-	    /* Double when small.  */
-	    work->proctypevec_size *= 2;
-	  else
-	    {
-	      /* Grow slower when large.  */
-	      if (work->proctypevec_size > (INT_MAX / 3) * 2)
-                xmalloc_failed (INT_MAX);
-              work->proctypevec_size = (work->proctypevec_size * 3 / 2);
-	    }   
-          work->proctypevec
-            = XRESIZEVEC (int, work->proctypevec, work->proctypevec_size);
-	}
-    }
-    work->proctypevec [work->nproctypes++] = typevec_index;
-}
-
-static void
-pop_processed_type (struct work_stuff *work)
-{
-  work->nproctypes--;
-}
-
-static void
-remember_type (struct work_stuff *work, const char *start, int len)
-{
-  char *tem;
-
-  if (work->forgetting_types)
-    return;
-
-  if (work -> ntypes >= work -> typevec_size)
-    {
-      if (work -> typevec_size == 0)
-	{
-	  work -> typevec_size = 3;
-	  work -> typevec = XNEWVEC (char *, work->typevec_size);
-	}
-      else
-	{
-          if (work -> typevec_size > INT_MAX / 2)
-	    xmalloc_failed (INT_MAX);
-	  work -> typevec_size *= 2;
-	  work -> typevec
-	    = XRESIZEVEC (char *, work->typevec, work->typevec_size);
-	}
-    }
-  tem = XNEWVEC (char, len + 1);
-  memcpy (tem, start, len);
-  tem[len] = '\0';
-  work -> typevec[work -> ntypes++] = tem;
-}
-
-
-/* Remember a K type class qualifier. */
-static void
-remember_Ktype (struct work_stuff *work, const char *start, int len)
-{
-  char *tem;
-
-  if (work -> numk >= work -> ksize)
-    {
-      if (work -> ksize == 0)
-	{
-	  work -> ksize = 5;
-	  work -> ktypevec = XNEWVEC (char *, work->ksize);
-	}
-      else
-	{
-          if (work -> ksize > INT_MAX / 2)
-	    xmalloc_failed (INT_MAX);
-	  work -> ksize *= 2;
-	  work -> ktypevec
-	    = XRESIZEVEC (char *, work->ktypevec, work->ksize);
-	}
-    }
-  tem = XNEWVEC (char, len + 1);
-  memcpy (tem, start, len);
-  tem[len] = '\0';
-  work -> ktypevec[work -> numk++] = tem;
-}
-
-/* Register a B code, and get an index for it. B codes are registered
-   as they are seen, rather than as they are completed, so map<temp<char> >
-   registers map<temp<char> > as B0, and temp<char> as B1 */
-
-static int
-register_Btype (struct work_stuff *work)
-{
-  int ret;
-
-  if (work -> numb >= work -> bsize)
-    {
-      if (work -> bsize == 0)
-	{
-	  work -> bsize = 5;
-	  work -> btypevec = XNEWVEC (char *, work->bsize);
-	}
-      else
-	{
-          if (work -> bsize > INT_MAX / 2)
-	    xmalloc_failed (INT_MAX);
-	  work -> bsize *= 2;
-	  work -> btypevec
-	    = XRESIZEVEC (char *, work->btypevec, work->bsize);
-	}
-    }
-  ret = work -> numb++;
-  work -> btypevec[ret] = NULL;
-  return(ret);
-}
-
-/* Store a value into a previously registered B code type. */
-
-static void
-remember_Btype (struct work_stuff *work, const char *start,
-                int len, int index)
-{
-  char *tem;
-
-  tem = XNEWVEC (char, len + 1);
-  memcpy (tem, start, len);
-  tem[len] = '\0';
-  work -> btypevec[index] = tem;
-}
-
-/* Lose all the info related to B and K type codes. */
-static void
-forget_B_and_K_types (struct work_stuff *work)
-{
-  int i;
-
-  while (work -> numk > 0)
-    {
-      i = --(work -> numk);
-      if (work -> ktypevec[i] != NULL)
-	{
-	  free (work -> ktypevec[i]);
-	  work -> ktypevec[i] = NULL;
-	}
-    }
-
-  while (work -> numb > 0)
-    {
-      i = --(work -> numb);
-      if (work -> btypevec[i] != NULL)
-	{
-	  free (work -> btypevec[i]);
-	  work -> btypevec[i] = NULL;
-	}
-    }
-}
-/* Forget the remembered types, but not the type vector itself.  */
-
-static void
-forget_types (struct work_stuff *work)
-{
-  int i;
-
-  while (work -> ntypes > 0)
-    {
-      i = --(work -> ntypes);
-      if (work -> typevec[i] != NULL)
-	{
-	  free (work -> typevec[i]);
-	  work -> typevec[i] = NULL;
-	}
-    }
-}
-
-/* Process the argument list part of the signature, after any class spec
-   has been consumed, as well as the first 'F' character (if any).  For
-   example:
-
-   "__als__3fooRT0"		=>	process "RT0"
-   "complexfunc5__FPFPc_PFl_i"	=>	process "PFPc_PFl_i"
-
-   DECLP must be already initialised, usually non-empty.  It won't be freed
-   on failure.
-
-   Note that g++ differs significantly from ARM and lucid style mangling
-   with regards to references to previously seen types.  For example, given
-   the source fragment:
-
-     class foo {
-       public:
-       foo::foo (int, foo &ia, int, foo &ib, int, foo &ic);
-     };
-
-     foo::foo (int, foo &ia, int, foo &ib, int, foo &ic) { ia = ib = ic; }
-     void foo (int, foo &ia, int, foo &ib, int, foo &ic) { ia = ib = ic; }
-
-   g++ produces the names:
-
-     __3fooiRT0iT2iT2
-     foo__FiR3fooiT1iT1
-
-   while lcc (and presumably other ARM style compilers as well) produces:
-
-     foo__FiR3fooT1T2T1T2
-     __ct__3fooFiR3fooT1T2T1T2
-
-   Note that g++ bases its type numbers starting at zero and counts all
-   previously seen types, while lucid/ARM bases its type numbers starting
-   at one and only considers types after it has seen the 'F' character
-   indicating the start of the function args.  For lucid/ARM style, we
-   account for this difference by discarding any previously seen types when
-   we see the 'F' character, and subtracting one from the type number
-   reference.
-
- */
-
-static int
-demangle_args (struct work_stuff *work, const char **mangled,
-               string *declp)
-{
-  string arg;
-  int need_comma = 0;
-  int r;
-  int t;
-  const char *tem;
-  char temptype;
-
-  if (PRINT_ARG_TYPES)
-    {
-      string_append (declp, "(");
-      if (**mangled == '\0')
-	{
-	  string_append (declp, "void");
-	}
-    }
-
-  while ((**mangled != '_' && **mangled != '\0' && **mangled != 'e')
-	 || work->nrepeats > 0)
-    {
-      if ((**mangled == 'N') || (**mangled == 'T'))
-	{
-	  temptype = *(*mangled)++;
-
-	  if (temptype == 'N')
-	    {
-	      if (!get_count (mangled, &r))
-		{
-		  return (0);
-		}
-	    }
-	  else
-	    {
-	      r = 1;
-	    }
-          if ((HP_DEMANGLING || ARM_DEMANGLING || EDG_DEMANGLING) && work -> ntypes >= 10)
-            {
-              /* If we have 10 or more types we might have more than a 1 digit
-                 index so we'll have to consume the whole count here. This
-                 will lose if the next thing is a type name preceded by a
-                 count but it's impossible to demangle that case properly
-                 anyway. Eg if we already have 12 types is T12Pc "(..., type1,
-                 Pc, ...)"  or "(..., type12, char *, ...)" */
-              if ((t = consume_count(mangled)) <= 0)
-                {
-                  return (0);
-                }
-            }
-          else
-	    {
-	      if (!get_count (mangled, &t))
-	    	{
-	          return (0);
-	    	}
-	    }
-	  if (LUCID_DEMANGLING || ARM_DEMANGLING || HP_DEMANGLING || EDG_DEMANGLING)
-	    {
-	      t--;
-	    }
-	  /* Validate the type index.  Protect against illegal indices from
-	     malformed type strings.  */
-	  if ((t < 0) || (t >= work -> ntypes))
-	    {
-	      return (0);
-	    }
-	  while (work->nrepeats > 0 || --r >= 0)
-	    {
-	      tem = work -> typevec[t];
-	      if (need_comma && PRINT_ARG_TYPES)
-		{
-		  string_append (declp, ", ");
-		}
-	      push_processed_type (work, t);  
-	      if (!do_arg (work, &tem, &arg))
-		{
-		  pop_processed_type (work);
-		  return (0);
-		}
-	      pop_processed_type (work);
-	      if (PRINT_ARG_TYPES)
-		{
-		  string_appends (declp, &arg);
-		}
-	      string_delete (&arg);
-	      need_comma = 1;
-	    }
-	}
-      else
-	{
-	  if (need_comma && PRINT_ARG_TYPES)
-	    string_append (declp, ", ");
-	  if (!do_arg (work, mangled, &arg))
-	    return (0);
-	  if (PRINT_ARG_TYPES)
-	    string_appends (declp, &arg);
-	  string_delete (&arg);
-	  need_comma = 1;
-	}
-    }
-
-  if (**mangled == 'e')
-    {
-      (*mangled)++;
-      if (PRINT_ARG_TYPES)
-	{
-	  if (need_comma)
-	    {
-	      string_append (declp, ",");
-	    }
-	  string_append (declp, "...");
-	}
-    }
-
-  if (PRINT_ARG_TYPES)
-    {
-      string_append (declp, ")");
-    }
-  return (1);
-}
-
-/* Like demangle_args, but for demangling the argument lists of function
-   and method pointers or references, not top-level declarations.  */
-
-static int
-demangle_nested_args (struct work_stuff *work, const char **mangled,
-                      string *declp)
-{
-  string* saved_previous_argument;
-  int result;
-  int saved_nrepeats;
-
-  /* The G++ name-mangling algorithm does not remember types on nested
-     argument lists, unless -fsquangling is used, and in that case the
-     type vector updated by remember_type is not used.  So, we turn
-     off remembering of types here.  */
-  ++work->forgetting_types;
-
-  /* For the repeat codes used with -fsquangling, we must keep track of
-     the last argument.  */
-  saved_previous_argument = work->previous_argument;
-  saved_nrepeats = work->nrepeats;
-  work->previous_argument = 0;
-  work->nrepeats = 0;
-
-  /* Actually demangle the arguments.  */
-  result = demangle_args (work, mangled, declp);
-
-  /* Restore the previous_argument field.  */
-  if (work->previous_argument)
-    {
-      string_delete (work->previous_argument);
-      free ((char *) work->previous_argument);
-    }
-  work->previous_argument = saved_previous_argument;
-  --work->forgetting_types;
-  work->nrepeats = saved_nrepeats;
-
-  return result;
-}
-
-/* Returns 1 if a valid function name was found or 0 otherwise.  */
-
-static int 
-demangle_function_name (struct work_stuff *work, const char **mangled,
-                        string *declp, const char *scan)
-{
-  size_t i;
-  string type;
-  const char *tem;
-
-  string_appendn (declp, (*mangled), scan - (*mangled));
-  string_need (declp, 1);
-  *(declp -> p) = '\0';
-
-  /* Consume the function name, including the "__" separating the name
-     from the signature.  We are guaranteed that SCAN points to the
-     separator.  */
-
-  (*mangled) = scan + 2;
-  /* We may be looking at an instantiation of a template function:
-     foo__Xt1t2_Ft3t4, where t1, t2, ... are template arguments and a
-     following _F marks the start of the function arguments.  Handle
-     the template arguments first. */
-
-  if (HP_DEMANGLING && (**mangled == 'X'))
-    {
-      demangle_arm_hp_template (work, mangled, 0, declp);
-      /* This leaves MANGLED pointing to the 'F' marking func args */
-    }
-
-  if (LUCID_DEMANGLING || ARM_DEMANGLING || HP_DEMANGLING || EDG_DEMANGLING)
-    {
-
-      /* See if we have an ARM style constructor or destructor operator.
-	 If so, then just record it, clear the decl, and return.
-	 We can't build the actual constructor/destructor decl until later,
-	 when we recover the class name from the signature.  */
-
-      if (strcmp (declp -> b, "__ct") == 0)
-	{
-	  work -> constructor += 1;
-	  string_clear (declp);
-	  return 1;
-	}
-      else if (strcmp (declp -> b, "__dt") == 0)
-	{
-	  work -> destructor += 1;
-	  string_clear (declp);
-	  return 1;
-	}
-    }
-
-  if (declp->p - declp->b >= 3
-      && declp->b[0] == 'o'
-      && declp->b[1] == 'p'
-      && strchr (cplus_markers, declp->b[2]) != NULL)
-    {
-      /* see if it's an assignment expression */
-      if (declp->p - declp->b >= 10 /* op$assign_ */
-	  && memcmp (declp->b + 3, "assign_", 7) == 0)
-	{
-	  for (i = 0; i < ARRAY_SIZE (optable); i++)
-	    {
-	      int len = declp->p - declp->b - 10;
-	      if ((int) strlen (optable[i].in) == len
-		  && memcmp (optable[i].in, declp->b + 10, len) == 0)
-		{
-		  string_clear (declp);
-		  string_append (declp, "operator");
-		  string_append (declp, optable[i].out);
-		  string_append (declp, "=");
-		  break;
-		}
-	    }
-	}
-      else
-	{
-	  for (i = 0; i < ARRAY_SIZE (optable); i++)
-	    {
-	      int len = declp->p - declp->b - 3;
-	      if ((int) strlen (optable[i].in) == len
-		  && memcmp (optable[i].in, declp->b + 3, len) == 0)
-		{
-		  string_clear (declp);
-		  string_append (declp, "operator");
-		  string_append (declp, optable[i].out);
-		  break;
-		}
-	    }
-	}
-    }
-  else if (declp->p - declp->b >= 5 && memcmp (declp->b, "type", 4) == 0
-	   && strchr (cplus_markers, declp->b[4]) != NULL)
-    {
-      /* type conversion operator */
-      tem = declp->b + 5;
-      if (do_type (work, &tem, &type))
-	{
-	  string_clear (declp);
-	  string_append (declp, "operator ");
-	  string_appends (declp, &type);
-	  string_delete (&type);
-	}
-    }
-  else if (declp->b[0] == '_' && declp->b[1] == '_'
-	   && declp->b[2] == 'o' && declp->b[3] == 'p')
-    {
-      /* ANSI.  */
-      /* type conversion operator.  */
-      tem = declp->b + 4;
-      if (do_type (work, &tem, &type))
-	{
-	  string_clear (declp);
-	  string_append (declp, "operator ");
-	  string_appends (declp, &type);
-	  string_delete (&type);
-	}
-    }
-  else if (declp->b[0] == '_' && declp->b[1] == '_'
-	   && ISLOWER((unsigned char)declp->b[2])
-	   && ISLOWER((unsigned char)declp->b[3]))
-    {
-      if (declp->b[4] == '\0')
-	{
-	  /* Operator.  */
-	  for (i = 0; i < ARRAY_SIZE (optable); i++)
-	    {
-	      if (strlen (optable[i].in) == 2
-		  && memcmp (optable[i].in, declp->b + 2, 2) == 0)
-		{
-		  string_clear (declp);
-		  string_append (declp, "operator");
-		  string_append (declp, optable[i].out);
-		  break;
-		}
-	    }
-	}
-      else
-	{
-	  if (declp->b[2] == 'a' && declp->b[5] == '\0')
-	    {
-	      /* Assignment.  */
-	      for (i = 0; i < ARRAY_SIZE (optable); i++)
-		{
-		  if (strlen (optable[i].in) == 3
-		      && memcmp (optable[i].in, declp->b + 2, 3) == 0)
-		    {
-		      string_clear (declp);
-		      string_append (declp, "operator");
-		      string_append (declp, optable[i].out);
-		      break;
-		    }
-		}
-	    }
-	}
-    }
-
-  /* If a function name was obtained but it's not valid, we were not
-     successful.  */
-  if (LEN_STRING (declp) == 1 && declp->b[0] == '.')
-    return 0;
-  else
-    return 1;
-}
-
-/* a mini string-handling package */
-
-static void
-string_need (string *s, int n)
-{
-  int tem;
-
-  if (s->b == NULL)
-    {
-      if (n < 32)
-	{
-	  n = 32;
-	}
-      s->p = s->b = XNEWVEC (char, n);
-      s->e = s->b + n;
-    }
-  else if (s->e - s->p < n)
-    {
-      tem = s->p - s->b;
-      if (n > INT_MAX / 2 - tem)
-        xmalloc_failed (INT_MAX); 
-      n += tem;
-      n *= 2;
-      s->b = XRESIZEVEC (char, s->b, n);
-      s->p = s->b + tem;
-      s->e = s->b + n;
-    }
-}
-
-static void
-string_delete (string *s)
-{
-  if (s->b != NULL)
-    {
-      free (s->b);
-      s->b = s->e = s->p = NULL;
-    }
-}
-
-static void
-string_init (string *s)
-{
-  s->b = s->p = s->e = NULL;
-}
-
-static void
-string_clear (string *s)
-{
-  s->p = s->b;
-}
-
-#if 0
-
-static int
-string_empty (string *s)
-{
-  return (s->b == s->p);
-}
-
-#endif
-
-static void
-string_append (string *p, const char *s)
-{
-  int n;
-  if (s == NULL || *s == '\0')
-    return;
-  n = strlen (s);
-  string_need (p, n);
-  memcpy (p->p, s, n);
-  p->p += n;
-}
-
-static void
-string_appends (string *p, string *s)
-{
-  int n;
-
-  if (s->b != s->p)
-    {
-      n = s->p - s->b;
-      string_need (p, n);
-      memcpy (p->p, s->b, n);
-      p->p += n;
-    }
-}
-
-static void
-string_appendn (string *p, const char *s, int n)
-{
-  if (n != 0)
-    {
-      string_need (p, n);
-      memcpy (p->p, s, n);
-      p->p += n;
-    }
-}
-
-static void
-string_prepend (string *p, const char *s)
-{
-  if (s != NULL && *s != '\0')
-    {
-      string_prependn (p, s, strlen (s));
-    }
-}
-
-static void
-string_prepends (string *p, string *s)
-{
-  if (s->b != s->p)
-    {
-      string_prependn (p, s->b, s->p - s->b);
-    }
-}
-
-static void
-string_prependn (string *p, const char *s, int n)
-{
-  char *q;
-
-  if (n != 0)
-    {
-      string_need (p, n);
-      for (q = p->p - 1; q >= p->b; q--)
-	{
-	  q[n] = q[0];
-	}
-      memcpy (p->b, s, n);
-      p->p += n;
-    }
-}
-
-static void
-string_append_template_idx (string *s, int idx)
-{
-  char buf[INTBUF_SIZE + 1 /* 'T' */];
-  sprintf(buf, "T%d", idx);
-  string_append (s, buf);
-}
--- libiberty/testsuite/demangle-expected
+++ libiberty/testsuite/demangle-expected
@@ -20,3315 +20,64 @@
 # A line starting with `#' is ignored.
 # However, blank lines in this file are NOT ignored.
 #
---format=gnu --no-params
-AddAlignment__9ivTSolverUiP12ivInteractorP7ivTGlue
-ivTSolver::AddAlignment(unsigned int, ivInteractor *, ivTGlue *)
-ivTSolver::AddAlignment
-#
---format=gnu --no-params
-ArrowheadIntersects__9ArrowLineP9ArrowheadR6BoxObjP7Graphic
-ArrowLine::ArrowheadIntersects(Arrowhead *, BoxObj &, Graphic *)
-ArrowLine::ArrowheadIntersects
-#
---format=gnu --no-params
-ArrowheadIntersects__9ArrowLineP9ArrowheadO6BoxObjP7Graphic
-ArrowLine::ArrowheadIntersects(Arrowhead *, BoxObj &&, Graphic *)
-ArrowLine::ArrowheadIntersects
-#
---format=gnu --no-params
-AtEnd__13ivRubberGroup
-ivRubberGroup::AtEnd(void)
-ivRubberGroup::AtEnd
-#
---format=gnu --no-params
-BgFilter__9ivTSolverP12ivInteractor
-ivTSolver::BgFilter(ivInteractor *)
-ivTSolver::BgFilter
-#
---format=gnu --no-params
-Check__6UArrayi
-UArray::Check(int)
-UArray::Check
-#
---format=gnu --no-params
-CoreConstDecls__8TextCodeR7ostream
-TextCode::CoreConstDecls(ostream &)
-TextCode::CoreConstDecls
-#
---format=gnu --no-params
-CoreConstDecls__8TextCodeO7ostream
-TextCode::CoreConstDecls(ostream &&)
-TextCode::CoreConstDecls
-#
---format=gnu --no-params
-Detach__8StateVarP12StateVarView
-StateVar::Detach(StateVarView *)
-StateVar::Detach
-#
---format=gnu --no-params
-Done__9ComponentG8Iterator
-Component::Done(Iterator)
-Component::Done
-#
---format=gnu --no-params
-Effect__11RelateManipR7ivEvent
-RelateManip::Effect(ivEvent &)
-RelateManip::Effect
-#
---format=gnu --no-params
-Effect__11RelateManipO7ivEvent
-RelateManip::Effect(ivEvent &&)
-RelateManip::Effect
-#
---format=gnu --no-params
-FindFixed__FRP4CNetP4CNet
-FindFixed(CNet *&, CNet *)
-FindFixed
-#
---format=gnu --no-params
-FindFixed__FOP4CNetP4CNet
-FindFixed(CNet *&&, CNet *)
-FindFixed
-#
---format=gnu --no-params
-Fix48_abort__FR8twolongs
-Fix48_abort(twolongs &)
-Fix48_abort
-#
---format=gnu --no-params
-Fix48_abort__FO8twolongs
-Fix48_abort(twolongs &&)
-Fix48_abort
-#
---format=gnu --no-params
-GetBarInfo__15iv2_6_VScrollerP13ivPerspectiveRiT2
-iv2_6_VScroller::GetBarInfo(ivPerspective *, int &, int &)
-iv2_6_VScroller::GetBarInfo
-#
---format=gnu --no-params
-GetBarInfo__15iv2_6_VScrollerP13ivPerspectiveOiT2
-iv2_6_VScroller::GetBarInfo(ivPerspective *, int &&, int &&)
-iv2_6_VScroller::GetBarInfo
-#
---format=gnu --no-params
-GetBgColor__C9ivPainter
-ivPainter::GetBgColor(void) const
-ivPainter::GetBgColor
-#
---format=gnu --no-params
-InsertBody__15H_PullrightMenuii
-H_PullrightMenu::InsertBody(int, int)
-H_PullrightMenu::InsertBody
-#
---format=gnu --no-params
-InsertCharacter__9TextManipc
-TextManip::InsertCharacter(char)
-TextManip::InsertCharacter
-#
---format=gnu --no-params
-InsertToplevel__7ivWorldP12ivInteractorT1
-ivWorld::InsertToplevel(ivInteractor *, ivInteractor *)
-ivWorld::InsertToplevel
-#
---format=gnu --no-params
-InsertToplevel__7ivWorldP12ivInteractorT1iiUi
-ivWorld::InsertToplevel(ivInteractor *, ivInteractor *, int, int, unsigned int)
-ivWorld::InsertToplevel
-#
---format=gnu --no-params
-IsAGroup__FP11GraphicViewP11GraphicComp
-IsAGroup(GraphicView *, GraphicComp *)
-IsAGroup
-#
---format=gnu --no-params
-IsA__10ButtonCodeUl
-ButtonCode::IsA(unsigned long)
-ButtonCode::IsA
-#
---format=gnu --no-params
-ReadName__FR7istreamPc
-ReadName(istream &, char *)
-ReadName
-#
---format=gnu --no-params
-Redraw__13StringBrowseriiii
-StringBrowser::Redraw(int, int, int, int)
-StringBrowser::Redraw
-#
---format=gnu --no-params
-Rotate__13ivTransformerf
-ivTransformer::Rotate(float)
-ivTransformer::Rotate
-#
---format=gnu --no-params
-Rotated__C13ivTransformerf
-ivTransformer::Rotated(float) const
-ivTransformer::Rotated
-#
---format=gnu --no-params
-Round__Ff
-Round(float)
-Round
-#
---format=gnu --no-params
-SetExport__16MemberSharedNameUi
-MemberSharedName::SetExport(unsigned int)
-MemberSharedName::SetExport
-#
---format=gnu --no-params
-Set__14ivControlState13ControlStatusUi
-ivControlState::Set(ControlStatus, unsigned int)
-ivControlState::Set
-#
---format=gnu --no-params
-Set__5DFacePcii
-DFace::Set(char *, int, int)
-DFace::Set
-#
---format=gnu --no-params
-VConvert__9ivTSolverP12ivInteractorRP8TElementT2
-ivTSolver::VConvert(ivInteractor *, TElement *&, TElement *&)
-ivTSolver::VConvert
-#
---format=gnu --no-params
-VConvert__9ivTSolverP7ivTGlueRP8TElement
-ivTSolver::VConvert(ivTGlue *, TElement *&)
-ivTSolver::VConvert
-#
---format=gnu --no-params
-VOrder__9ivTSolverUiRP12ivInteractorT2
-ivTSolver::VOrder(unsigned int, ivInteractor *&, ivInteractor *&)
-ivTSolver::VOrder
-#
---format=gnu --no-params
-_10PageButton$__both
-PageButton::__both
-PageButton::__both
-#
---format=gnu --no-params
-_3RNG$singleMantissa
-RNG::singleMantissa
-RNG::singleMantissa
-#
---format=gnu --no-params
-_5IComp$_release
-IComp::_release
-IComp::_release
-#
---format=gnu --no-params
-_$_10BitmapComp
-BitmapComp::~BitmapComp(void)
-BitmapComp::~BitmapComp
-#
---format=gnu --no-params
-_$_9__io_defs
-__io_defs::~__io_defs(void)
-__io_defs::~__io_defs
-#
---format=gnu --no-params
-_$_Q23foo3bar
-foo::bar::~bar(void)
-foo::bar::~bar
-#
---format=gnu --no-params
-_$_Q33foo3bar4bell
-foo::bar::bell::~bell(void)
-foo::bar::bell::~bell
-#
---format=gnu --no-params
-__10ivTelltaleiP7ivGlyph
-ivTelltale::ivTelltale(int, ivGlyph *)
-ivTelltale::ivTelltale
-#
---format=gnu --no-params
-__10ivViewportiP12ivInteractorUi
-ivViewport::ivViewport(int, ivInteractor *, unsigned int)
-ivViewport::ivViewport
-#
---format=gnu --no-params
-__10ostrstream
-ostrstream::ostrstream(void)
-ostrstream::ostrstream
-#
---format=gnu --no-params
-__10ostrstreamPcii
-ostrstream::ostrstream(char *, int, int)
-ostrstream::ostrstream
-#
---format=gnu --no-params
-__11BitmapTablei
-BitmapTable::BitmapTable(int)
-BitmapTable::BitmapTable
-#
---format=gnu --no-params
-__12ViewportCodeP12ViewportComp
-ViewportCode::ViewportCode(ViewportComp *)
-ViewportCode::ViewportCode
-#
---format=gnu --no-params
-__12iv2_6_Borderii
-iv2_6_Border::iv2_6_Border(int, int)
-iv2_6_Border::iv2_6_Border
-#
---format=gnu --no-params
-__12ivBreak_Listl
-ivBreak_List::ivBreak_List(long)
-ivBreak_List::ivBreak_List
-#
---format=gnu --no-params
-__14iv2_6_MenuItemiP12ivInteractor
-iv2_6_MenuItem::iv2_6_MenuItem(int, ivInteractor *)
-iv2_6_MenuItem::iv2_6_MenuItem
-#
---format=gnu --no-params
-__20DisplayList_IteratorR11DisplayList
-DisplayList_Iterator::DisplayList_Iterator(DisplayList &)
-DisplayList_Iterator::DisplayList_Iterator
-#
---format=gnu --no-params
-__3fooRT0
-foo::foo(foo &)
-foo::foo
-#
---format=gnu --no-params
-__3fooiN31
-foo::foo(int, int, int, int)
-foo::foo
-#
---format=gnu --no-params
-__3fooiRT0iT2iT2
-foo::foo(int, foo &, int, foo &, int, foo &)
-foo::foo
-#
---format=gnu --no-params
-__6KeyMapPT0
-KeyMap::KeyMap(KeyMap *)
-KeyMap::KeyMap
-#
---format=gnu --no-params
-__8ArrowCmdP6EditorUiUi
-ArrowCmd::ArrowCmd(Editor *, unsigned int, unsigned int)
-ArrowCmd::ArrowCmd
-#
---format=gnu --no-params
-__9F_EllipseiiiiP7Graphic
-F_Ellipse::F_Ellipse(int, int, int, int, Graphic *)
-F_Ellipse::F_Ellipse
-#
---format=gnu --no-params
-__9FrameDataP9FrameCompi
-FrameData::FrameData(FrameComp *, int)
-FrameData::FrameData
-#
---format=gnu --no-params
-__9HVGraphicP9CanvasVarP7Graphic
-HVGraphic::HVGraphic(CanvasVar *, Graphic *)
-HVGraphic::HVGraphic
-#
---format=gnu --no-params
-__Q23foo3bar
-foo::bar::bar(void)
-foo::bar::bar
-#
---format=gnu --no-params
-__Q33foo3bar4bell
-foo::bar::bell::bell(void)
-foo::bar::bell::bell
-#
---format=gnu --no-params
-__aa__3fooRT0
-foo::operator&&(foo &)
-foo::operator&&
-#
---format=gnu --no-params
-__aad__3fooRT0
-foo::operator&=(foo &)
-foo::operator&=
-#
---format=gnu --no-params
-__ad__3fooRT0
-foo::operator&(foo &)
-foo::operator&
-#
---format=gnu --no-params
-__adv__3fooRT0
-foo::operator/=(foo &)
-foo::operator/=
-#
---format=gnu --no-params
-__aer__3fooRT0
-foo::operator^=(foo &)
-foo::operator^=
-#
---format=gnu --no-params
-__als__3fooRT0
-foo::operator<<=(foo &)
-foo::operator<<=
-#
---format=gnu --no-params
-__amd__3fooRT0
-foo::operator%=(foo &)
-foo::operator%=
-#
---format=gnu --no-params
-__ami__3fooRT0
-foo::operator-=(foo &)
-foo::operator-=
-#
---format=gnu --no-params
-__aml__3FixRT0
-Fix::operator*=(Fix &)
-Fix::operator*=
-#
---format=gnu --no-params
-__aml__5Fix16i
-Fix16::operator*=(int)
-Fix16::operator*=
-#
---format=gnu --no-params
-__aml__5Fix32RT0
-Fix32::operator*=(Fix32 &)
-Fix32::operator*=
-#
---format=gnu --no-params
-__aor__3fooRT0
-foo::operator|=(foo &)
-foo::operator|=
-#
---format=gnu --no-params
-__apl__3fooRT0
-foo::operator+=(foo &)
-foo::operator+=
-#
---format=gnu --no-params
-__ars__3fooRT0
-foo::operator>>=(foo &)
-foo::operator>>=
-#
---format=gnu --no-params
-__as__3fooRT0
-foo::operator=(foo &)
-foo::operator=
-#
---format=gnu --no-params
-__cl__3fooRT0
-foo::operator()(foo &)
-foo::operator()
-#
---format=gnu --no-params
-__cl__6Normal
-Normal::operator()(void)
-Normal::operator()
-#
---format=gnu --no-params
-__cl__6Stringii
-String::operator()(int, int)
-String::operator()
-#
---format=gnu --no-params
-__cm__3fooRT0
-foo::operator, (foo &)
-foo::operator, 
-#
---format=gnu --no-params
-__co__3foo
-foo::operator~(void)
-foo::operator~
-#
---format=gnu --no-params
-__dl__3fooPv
-foo::operator delete(void *)
-foo::operator delete
-#
---format=gnu --no-params
-__dv__3fooRT0
-foo::operator/(foo &)
-foo::operator/
-#
---format=gnu --no-params
-__eq__3fooRT0
-foo::operator==(foo &)
-foo::operator==
-#
---format=gnu --no-params
-__er__3fooRT0
-foo::operator^(foo &)
-foo::operator^
-#
---format=gnu --no-params
-__ge__3fooRT0
-foo::operator>=(foo &)
-foo::operator>=
-#
---format=gnu --no-params
-__gt__3fooRT0
-foo::operator>(foo &)
-foo::operator>
-#
---format=gnu --no-params
-__le__3fooRT0
-foo::operator<=(foo &)
-foo::operator<=
-#
---format=gnu --no-params
-__ls__3fooRT0
-foo::operator<<(foo &)
-foo::operator<<
-#
---format=gnu --no-params
-__ls__FR7ostreamPFR3ios_R3ios
-operator<<(ostream &, ios &(*)(ios &))
-operator<<
-#
---format=gnu --no-params
-__ls__FR7ostreamR3Fix
-operator<<(ostream &, Fix &)
-operator<<
-#
---format=gnu --no-params
-__lt__3fooRT0
-foo::operator<(foo &)
-foo::operator<
-#
---format=gnu --no-params
-__md__3fooRT0
-foo::operator%(foo &)
-foo::operator%
-#
---format=gnu --no-params
-__mi__3fooRT0
-foo::operator-(foo &)
-foo::operator-
-#
---format=gnu --no-params
-__ml__3fooRT0
-foo::operator*(foo &)
-foo::operator*
-#
---format=gnu --no-params
-__mm__3fooi
-foo::operator--(int)
-foo::operator--
-#
---format=gnu --no-params
-__ne__3fooRT0
-foo::operator!=(foo &)
-foo::operator!=
-#
---format=gnu --no-params
-__nt__3foo
-foo::operator!(void)
-foo::operator!
-#
---format=gnu --no-params
-__nw__3fooi
-foo::operator new(int)
-foo::operator new
-#
---format=gnu --no-params
-__oo__3fooRT0
-foo::operator||(foo &)
-foo::operator||
-#
---format=gnu --no-params
-__opPc__3foo
-foo::operator char *(void)
-foo::operator char *
-#
---format=gnu --no-params
-__opi__3foo
-foo::operator int(void)
-foo::operator int
-#
---format=gnu --no-params
-__or__3fooRT0
-foo::operator|(foo &)
-foo::operator|
-#
---format=gnu --no-params
-__pl__3fooRT0
-foo::operator+(foo &)
-foo::operator+
-#
---format=gnu --no-params
-__pp__3fooi
-foo::operator++(int)
-foo::operator++
-#
---format=gnu --no-params
-__rf__3foo
-foo::operator->(void)
-foo::operator->
-#
---format=gnu --no-params
-__rm__3fooRT0
-foo::operator->*(foo &)
-foo::operator->*
-#
---format=gnu --no-params
-__rs__3fooRT0
-foo::operator>>(foo &)
-foo::operator>>
-#
---format=gnu --no-params
-_new_Fix__FUs
-_new_Fix(unsigned short)
-_new_Fix
-#
---format=gnu --no-params
-_vt.foo
-foo virtual table
-foo virtual table
-#
---format=gnu --no-params
-_vt.foo.bar
-foo::bar virtual table
-foo::bar virtual table
-#
---format=gnu --no-params
-_vt$foo
-foo virtual table
-foo virtual table
-#
---format=gnu --no-params
-_vt$foo$bar
-foo::bar virtual table
-foo::bar virtual table
-#
---format=gnu --no-params
-append__7ivGlyphPT0
-ivGlyph::append(ivGlyph *)
-ivGlyph::append
-#
---format=gnu --no-params
-clearok__FP7_win_sti
-clearok(_win_st *, int)
-clearok
-#
---format=gnu --no-params
-complexfunc2__FPFPc_i
-complexfunc2(int (*)(char *))
-complexfunc2
-#
---format=gnu --no-params
-complexfunc3__FPFPFPl_s_i
-complexfunc3(int (*)(short (*)(long *)))
-complexfunc3
-#
---format=gnu --no-params
-complexfunc4__FPFPFPc_s_i
-complexfunc4(int (*)(short (*)(char *)))
-complexfunc4
-#
---format=gnu --no-params
-complexfunc5__FPFPc_PFl_i
-complexfunc5(int (*(*)(char *))(long))
-complexfunc5
-#
---format=gnu --no-params
-complexfunc6__FPFPi_PFl_i
-complexfunc6(int (*(*)(int *))(long))
-complexfunc6
-#
---format=gnu --no-params
-complexfunc7__FPFPFPc_i_PFl_i
-complexfunc7(int (*(*)(int (*)(char *)))(long))
-complexfunc7
-#
---format=gnu --no-params
-foo__FiN30
-foo(int, int, int, int)
-foo
-#
---format=gnu --no-params
-foo__FiR3fooiT1iT1
-foo(int, foo &, int, foo &, int, foo &)
-foo
-#
---format=gnu --no-params
-foo___3barl
-bar::foo_(long)
-bar::foo_
-#
---format=gnu --no-params
-insert__15ivClippingStacklRP8_XRegion
-ivClippingStack::insert(long, _XRegion *&)
-ivClippingStack::insert
-#
---format=gnu --no-params
-insert__16ChooserInfo_ListlR11ChooserInfo
-ChooserInfo_List::insert(long, ChooserInfo &)
-ChooserInfo_List::insert
-#
---format=gnu --no-params
-insert__17FontFamilyRepListlRP15ivFontFamilyRep
-FontFamilyRepList::insert(long, ivFontFamilyRep *&)
-FontFamilyRepList::insert
-#
---format=gnu --no-params
-leaveok__FP7_win_stc
-leaveok(_win_st *, char)
-leaveok
-#
---format=gnu --no-params
-left_mover__C7ivMFKitP12ivAdjustableP7ivStyle
-ivMFKit::left_mover(ivAdjustable *, ivStyle *) const
-ivMFKit::left_mover
-#
---format=gnu --no-params
-overload1arg__FSc
-overload1arg(signed char)
-overload1arg
-#
---format=gnu --no-params
-overload1arg__FUc
-overload1arg(unsigned char)
-overload1arg
-#
---format=gnu --no-params
-overload1arg__FUi
-overload1arg(unsigned int)
-overload1arg
-#
---format=gnu --no-params
-overload1arg__FUl
-overload1arg(unsigned long)
-overload1arg
-#
---format=gnu --no-params
-overload1arg__FUs
-overload1arg(unsigned short)
-overload1arg
-#
---format=gnu --no-params
-overload1arg__Fc
-overload1arg(char)
-overload1arg
-#
---format=gnu --no-params
-overload1arg__Fd
-overload1arg(double)
-overload1arg
-#
---format=gnu --no-params
-overload1arg__Ff
-overload1arg(float)
-overload1arg
-#
---format=gnu --no-params
-overload1arg__Fi
-overload1arg(int)
-overload1arg
-#
---format=gnu --no-params
-overload1arg__Fl
-overload1arg(long)
-overload1arg
-#
---format=gnu --no-params
-overload1arg__Fs
-overload1arg(short)
-overload1arg
-#
---format=gnu --no-params
-overload1arg__Fv
-overload1arg(void)
-overload1arg
-#
---format=gnu --no-params
-overloadargs__Fi
-overloadargs(int)
-overloadargs
-#
---format=gnu --no-params
-overloadargs__Fii
-overloadargs(int, int)
-overloadargs
-#
---format=gnu --no-params
-overloadargs__Fiii
-overloadargs(int, int, int)
-overloadargs
-#
---format=gnu --no-params
-overloadargs__Fiiii
-overloadargs(int, int, int, int)
-overloadargs
-#
---format=gnu --no-params
-overloadargs__Fiiiii
-overloadargs(int, int, int, int, int)
-overloadargs
-#
---format=gnu --no-params
-overloadargs__Fiiiiii
-overloadargs(int, int, int, int, int, int)
-overloadargs
-#
---format=gnu --no-params
-overloadargs__Fiiiiiii
-overloadargs(int, int, int, int, int, int, int)
-overloadargs
-#
---format=gnu --no-params
-overloadargs__Fiiiiiiii
-overloadargs(int, int, int, int, int, int, int, int)
-overloadargs
-#
---format=gnu --no-params
-overloadargs__Fiiiiiiiii
-overloadargs(int, int, int, int, int, int, int, int, int)
-overloadargs
-#
---format=gnu --no-params
-overloadargs__Fiiiiiiiiii
-overloadargs(int, int, int, int, int, int, int, int, int, int)
-overloadargs
-#
---format=gnu --no-params
-overloadargs__Fiiiiiiiiiii
-overloadargs(int, int, int, int, int, int, int, int, int, int, int)
-overloadargs
-#
---format=gnu --no-params
-poke__8ivRasterUlUlffff
-ivRaster::poke(unsigned long, unsigned long, float, float, float, float)
-ivRaster::poke
-#
---format=gnu --no-params
-polar__Fdd
-polar(double, double)
-polar
-#
---format=gnu --no-params
-scale__13ivTransformerff
-ivTransformer::scale(float, float)
-ivTransformer::scale
-#
---format=gnu --no-params
-sgetn__7filebufPci
-filebuf::sgetn(char *, int)
-filebuf::sgetn
-#
---format=gnu --no-params
-shift__FP5_FrepiT0
-shift(_Frep *, int, _Frep *)
-shift
-#
---format=gnu --no-params
-test__C6BitSeti
-BitSet::test(int) const
-BitSet::test
-#
---format=gnu --no-params
-test__C6BitSetii
-BitSet::test(int, int) const
-BitSet::test
-#
---format=gnu --no-params
-text_source__8Documentl
-Document::text_source(long)
-Document::text_source
-#
---format=gnu --no-params
-variance__6Erlangd
-Erlang::variance(double)
-Erlang::variance
-#
---format=gnu --no-params
-view__14DocumentViewerP8ItemViewP11TabularItem
-DocumentViewer::view(ItemView *, TabularItem *)
-DocumentViewer::view
-#
---format=gnu --no-params
-xy_extents__11ivExtensionffff
-ivExtension::xy_extents(float, float, float, float)
-ivExtension::xy_extents
-#
---format=gnu --no-params
-zero__8osMemoryPvUi
-osMemory::zero(void *, unsigned int)
-osMemory::zero
-#
---format=gnu --no-params
-_2T4$N
-T4::N
-T4::N
-#
---format=gnu --no-params
-_Q22T42t1$N
-T4::t1::N
-T4::t1::N
-#
---format=gnu --no-params
-get__2T1
-T1::get(void)
-T1::get
-#
---format=gnu --no-params
-get__Q22T11a
-T1::a::get(void)
-T1::a::get
-#
---format=gnu --no-params
-get__Q32T11a1b
-T1::a::b::get(void)
-T1::a::b::get
-#
---format=gnu --no-params
-get__Q42T11a1b1c
-T1::a::b::c::get(void)
-T1::a::b::c::get
-#
---format=gnu --no-params
-get__Q52T11a1b1c1d
-T1::a::b::c::d::get(void)
-T1::a::b::c::d::get
-#
---format=gnu --no-params
-put__2T1i
-T1::put(int)
-T1::put
-#
---format=gnu --no-params
-put__Q22T11ai
-T1::a::put(int)
-T1::a::put
-#
---format=gnu --no-params
-put__Q32T11a1bi
-T1::a::b::put(int)
-T1::a::b::put
-#
---format=gnu --no-params
-put__Q42T11a1b1ci
-T1::a::b::c::put(int)
-T1::a::b::c::put
-#
---format=gnu --no-params
-put__Q52T11a1b1c1di
-T1::a::b::c::d::put(int)
-T1::a::b::c::d::put
-#
---format=gnu --no-params
-bar__3fooPv
-foo::bar(void *)
-foo::bar
-#
---format=gnu --no-params
-bar__C3fooPv
-foo::bar(void *) const
-foo::bar
-#
---format=gnu --no-params
-__eq__3fooRT0
-foo::operator==(foo &)
-foo::operator==
-#
---format=gnu --no-params
-__eq__C3fooR3foo
-foo::operator==(foo &) const
-foo::operator==
-#
---format=gnu --no-params
-elem__t6vector1Zdi
-vector<double>::elem(int)
-vector<double>::elem
-#
---format=gnu --no-params
-elem__t6vector1Zii
-vector<int>::elem(int)
-vector<int>::elem
-#
---format=gnu --no-params
-__t6vector1Zdi
-vector<double>::vector(int)
-vector<double>::vector
-#
---format=gnu --no-params
-__t6vector1Zii
-vector<int>::vector(int)
-vector<int>::vector
-#
---format=gnu --no-params
-_$_t6vector1Zdi
-vector<double>::~vector(int)
-vector<double>::~vector
-#
---format=gnu --no-params
-_$_t6vector1Zii
-vector<int>::~vector(int)
-vector<int>::~vector
-#
---format=gnu --no-params
-__nw__t2T11ZcUi
-T1<char>::operator new(unsigned int)
-T1<char>::operator new
-#
---format=gnu --no-params
-__nw__t2T11Z1tUi
-T1<t>::operator new(unsigned int)
-T1<t>::operator new
-#
---format=gnu --no-params
-__dl__t2T11ZcPv
-T1<char>::operator delete(void *)
-T1<char>::operator delete
-#
---format=gnu --no-params
-__dl__t2T11Z1tPv
-T1<t>::operator delete(void *)
-T1<t>::operator delete
-#
---format=gnu --no-params
-__t2T11Zci
-T1<char>::T1(int)
-T1<char>::T1
-#
---format=gnu --no-params
-__t2T11Zc
-T1<char>::T1(void)
-T1<char>::T1
-#
---format=gnu --no-params
-__t2T11Z1ti
-T1<t>::T1(int)
-T1<t>::T1
-#
---format=gnu --no-params
-__t2T11Z1t
-T1<t>::T1(void)
-T1<t>::T1
-#
---format=gnu --no-params
-__Q2t4List1Z10VHDLEntity3Pix
-List<VHDLEntity>::Pix::Pix(void)
-List<VHDLEntity>::Pix::Pix
-#
---format=gnu --no-params
-__Q2t4List1Z10VHDLEntity3PixPQ2t4List1Z10VHDLEntity7element
-List<VHDLEntity>::Pix::Pix(List<VHDLEntity>::element *)
-List<VHDLEntity>::Pix::Pix
-#
---format=gnu --no-params
-__Q2t4List1Z10VHDLEntity3PixRCQ2t4List1Z10VHDLEntity3Pix
-List<VHDLEntity>::Pix::Pix(List<VHDLEntity>::Pix const &)
-List<VHDLEntity>::Pix::Pix
-#
---format=gnu --no-params
-__Q2t4List1Z10VHDLEntity3PixOCQ2t4List1Z10VHDLEntity3Pix
-List<VHDLEntity>::Pix::Pix(List<VHDLEntity>::Pix const &&)
-List<VHDLEntity>::Pix::Pix
-#
---format=gnu --no-params
-__Q2t4List1Z10VHDLEntity7elementRC10VHDLEntityPT0
-List<VHDLEntity>::element::element(VHDLEntity const &, List<VHDLEntity>::element *)
-List<VHDLEntity>::element::element
-#
---format=gnu --no-params
-__Q2t4List1Z10VHDLEntity7elementOC10VHDLEntityPT0
-List<VHDLEntity>::element::element(VHDLEntity const &&, List<VHDLEntity>::element *)
-List<VHDLEntity>::element::element
-#
---format=gnu --no-params
-__Q2t4List1Z10VHDLEntity7elementRCQ2t4List1Z10VHDLEntity7element
-List<VHDLEntity>::element::element(List<VHDLEntity>::element const &)
-List<VHDLEntity>::element::element
-#
---format=gnu --no-params
-__cl__C11VHDLLibraryGt4PixX3Z11VHDLLibraryZ14VHDLLibraryRepZt4List1Z10VHDLEntity
-VHDLLibrary::operator()(PixX<VHDLLibrary, VHDLLibraryRep, List<VHDLEntity> >) const
-VHDLLibrary::operator()
-#
---format=gnu --no-params
-__cl__Ct4List1Z10VHDLEntityRCQ2t4List1Z10VHDLEntity3Pix
-List<VHDLEntity>::operator()(List<VHDLEntity>::Pix const &) const
-List<VHDLEntity>::operator()
-#
---format=gnu --no-params
-__ne__FPvRCQ2t4List1Z10VHDLEntity3Pix
-operator!=(void *, List<VHDLEntity>::Pix const &)
-operator!=
-#
---format=gnu --no-params
-__ne__FPvRCt4PixX3Z11VHDLLibraryZ14VHDLLibraryRepZt4List1Z10VHDLEntity
-operator!=(void *, PixX<VHDLLibrary, VHDLLibraryRep, List<VHDLEntity> > const &)
-operator!=
-#
---format=gnu --no-params
-__t4List1Z10VHDLEntityRCt4List1Z10VHDLEntity
-List<VHDLEntity>::List(List<VHDLEntity> const &)
-List<VHDLEntity>::List
-#
---format=gnu --no-params
-__t4PixX3Z11VHDLLibraryZ14VHDLLibraryRepZt4List1Z10VHDLEntity
-PixX<VHDLLibrary, VHDLLibraryRep, List<VHDLEntity> >::PixX(void)
-PixX<VHDLLibrary, VHDLLibraryRep, List<VHDLEntity> >::PixX
-#
---format=gnu --no-params
-__t4PixX3Z11VHDLLibraryZ14VHDLLibraryRepZt4List1Z10VHDLEntityP14VHDLLibraryRepGQ2t4List1Z10VHDLEntity3Pix
-PixX<VHDLLibrary, VHDLLibraryRep, List<VHDLEntity> >::PixX(VHDLLibraryRep *, List<VHDLEntity>::Pix)
-PixX<VHDLLibrary, VHDLLibraryRep, List<VHDLEntity> >::PixX
-#
---format=gnu --no-params
-__t4PixX3Z11VHDLLibraryZ14VHDLLibraryRepZt4List1Z10VHDLEntityRCt4PixX3Z11VHDLLibraryZ14VHDLLibraryRepZt4List1Z10VHDLEntity
-PixX<VHDLLibrary, VHDLLibraryRep, List<VHDLEntity> >::PixX(PixX<VHDLLibrary, VHDLLibraryRep, List<VHDLEntity> > const &)
-PixX<VHDLLibrary, VHDLLibraryRep, List<VHDLEntity> >::PixX
-#
---format=gnu --no-params
-__t4PixX3Z11VHDLLibraryZ14VHDLLibraryRepZt4List1Z10VHDLEntityOCt4PixX3Z11VHDLLibraryZ14VHDLLibraryRepZt4List1Z10VHDLEntity
-PixX<VHDLLibrary, VHDLLibraryRep, List<VHDLEntity> >::PixX(PixX<VHDLLibrary, VHDLLibraryRep, List<VHDLEntity> > const &&)
-PixX<VHDLLibrary, VHDLLibraryRep, List<VHDLEntity> >::PixX
-#
---format=gnu --no-params
-nextE__C11VHDLLibraryRt4PixX3Z11VHDLLibraryZ14VHDLLibraryRepZt4List1Z10VHDLEntity
-VHDLLibrary::nextE(PixX<VHDLLibrary, VHDLLibraryRep, List<VHDLEntity> > &) const
-VHDLLibrary::nextE
-#
---format=gnu --no-params
-next__Ct4List1Z10VHDLEntityRQ2t4List1Z10VHDLEntity3Pix
-List<VHDLEntity>::next(List<VHDLEntity>::Pix &) const
-List<VHDLEntity>::next
-#
---format=gnu --no-params
-_GLOBAL_$D$set
-global destructors keyed to set
-global destructors keyed to set
-#
---format=gnu --no-params
-_GLOBAL_$I$set
-global constructors keyed to set
-global constructors keyed to set
-#
---format=gnu --no-params
-__as__t5ListS1ZUiRCt5ListS1ZUi
-ListS<unsigned int>::operator=(ListS<unsigned int> const &)
-ListS<unsigned int>::operator=
-#
---format=gnu --no-params
-__cl__Ct5ListS1ZUiRCQ2t5ListS1ZUi3Vix
-ListS<unsigned int>::operator()(ListS<unsigned int>::Vix const &) const
-ListS<unsigned int>::operator()
-#
---format=gnu --no-params
-__cl__Ct5SetLS1ZUiRCQ2t5SetLS1ZUi3Vix
-SetLS<unsigned int>::operator()(SetLS<unsigned int>::Vix const &) const
-SetLS<unsigned int>::operator()
-#
---format=gnu --no-params
-__t10ListS_link1ZUiRCUiPT0
-ListS_link<unsigned int>::ListS_link(unsigned int const &, ListS_link<unsigned int> *)
-ListS_link<unsigned int>::ListS_link
-#
---format=gnu --no-params
-__t10ListS_link1ZUiRCt10ListS_link1ZUi
-ListS_link<unsigned int>::ListS_link(ListS_link<unsigned int> const &)
-ListS_link<unsigned int>::ListS_link
-#
---format=gnu --no-params
-__t5ListS1ZUiRCt5ListS1ZUi
-ListS<unsigned int>::ListS(ListS<unsigned int> const &)
-ListS<unsigned int>::ListS
-#
---format=gnu --no-params
-next__Ct5ListS1ZUiRQ2t5ListS1ZUi3Vix
-ListS<unsigned int>::next(ListS<unsigned int>::Vix &) const
-ListS<unsigned int>::next
-#
---format=gnu --no-params
-__ne__FPvRCQ2t5SetLS1ZUi3Vix
-operator!=(void *, SetLS<unsigned int>::Vix const &)
-operator!=
-#
---format=gnu --no-params
-__t8ListElem1Z5LabelRt4List1Z5Label
-ListElem<Label>::ListElem(List<Label> &)
-ListElem<Label>::ListElem
-#
---format=gnu --no-params
-__t8BDDHookV1ZPcRCPc
-BDDHookV<char *>::BDDHookV(char *const &)
-BDDHookV<char *>::BDDHookV
-#
---format=gnu --no-params
-_vt$t8BDDHookV1ZPc
-BDDHookV<char *> virtual table
-BDDHookV<char *> virtual table
-#
---format=gnu --no-params
-__ne__FPvRCQ211BDDFunction4VixB
-operator!=(void *, BDDFunction::VixB const &)
-operator!=
-#
---format=gnu --no-params
-__eq__FPvRCQ211BDDFunction4VixB
-operator==(void *, BDDFunction::VixB const &)
-operator==
-#
---format=gnu --no-params
-relativeId__CQ36T_phi210T_preserve8FPC_nextRCQ26T_phi210T_preserveRC10Parameters
-T_phi2::T_preserve::FPC_next::relativeId(T_phi2::T_preserve const &, Parameters const &) const
-T_phi2::T_preserve::FPC_next::relativeId
-#
---format=lucid --no-params
-WS__FR7istream
-WS(istream &)
-WS
-#
---format=lucid --no-params
-__aa__3fooFR3foo
-foo::operator&&(foo &)
-foo::operator&&
-#
---format=lucid --no-params
-__aad__3fooFR3foo
-foo::operator&=(foo &)
-foo::operator&=
-#
---format=lucid --no-params
-__ad__3fooFR3foo
-foo::operator&(foo &)
-foo::operator&
-#
---format=lucid --no-params
-__adv__3fooFR3foo
-foo::operator/=(foo &)
-foo::operator/=
-#
---format=lucid --no-params
-__adv__7complexF7complex
-complex::operator/=(complex)
-complex::operator/=
-#
---format=lucid --no-params
-__aer__3fooFR3foo
-foo::operator^=(foo &)
-foo::operator^=
-#
---format=lucid --no-params
-__als__3fooFR3foo
-foo::operator<<=(foo &)
-foo::operator<<=
-#
---format=lucid --no-params
-__amd__3fooFR3foo
-foo::operator%=(foo &)
-foo::operator%=
-#
---format=lucid --no-params
-__ami__3fooFR3foo
-foo::operator-=(foo &)
-foo::operator-=
-#
---format=lucid --no-params
-__amu__3fooFR3foo
-foo::operator*=(foo &)
-foo::operator*=
-#
---format=lucid --no-params
-__amu__7complexF7complex
-complex::operator*=(complex)
-complex::operator*=
-#
---format=lucid --no-params
-__aor__3fooFR3foo
-foo::operator|=(foo &)
-foo::operator|=
-#
---format=lucid --no-params
-__apl__3fooFR3foo
-foo::operator+=(foo &)
-foo::operator+=
-#
---format=lucid --no-params
-__ars__3fooFR3foo
-foo::operator>>=(foo &)
-foo::operator>>=
-#
---format=lucid --no-params
-__as__18istream_withassignFP9streambuf
-istream_withassign::operator=(streambuf *)
-istream_withassign::operator=
-#
---format=lucid --no-params
-__as__18istream_withassignFR7istream
-istream_withassign::operator=(istream &)
-istream_withassign::operator=
-#
---format=lucid --no-params
-__as__3fooFR3foo
-foo::operator=(foo &)
-foo::operator=
-#
---format=lucid --no-params
-__as__3iosFR3ios
-ios::operator=(ios &)
-ios::operator=
-#
---format=lucid --no-params
-__cl__3fooFR3foo
-foo::operator()(foo &)
-foo::operator()
-#
---format=lucid --no-params
-__cm__3fooFR3foo
-foo::operator, (foo &)
-foo::operator, 
-#
---format=lucid --no-params
-__co__3fooFv
-foo::operator~(void)
-foo::operator~
-#
---format=lucid --no-params
-__ct__10istrstreamFPc
-istrstream::istrstream(char *)
-istrstream::istrstream
-#
---format=lucid --no-params
-__ct__10istrstreamFPci
-istrstream::istrstream(char *, int)
-istrstream::istrstream
-#
---format=lucid --no-params
-__ct__10ostrstreamFPciT2
-ostrstream::ostrstream(char *, int, int)
-ostrstream::ostrstream
-#
---format=lucid --no-params
-__ct__10ostrstreamFv
-ostrstream::ostrstream(void)
-ostrstream::ostrstream
-#
---format=lucid --no-params
-__ct__10smanip_intFPFR3iosi_R3iosi
-smanip_int::smanip_int(ios &(*)(ios &, int), int)
-smanip_int::smanip_int
-#
---format=lucid --no-params
-__ct__10smanip_intFPFO3iosi_O3iosi
-smanip_int::smanip_int(ios &&(*)(ios &&, int), int)
-smanip_int::smanip_int
-#
---format=lucid --no-params
-__ct__11fstreambaseFi
-fstreambase::fstreambase(int)
-fstreambase::fstreambase
-#
---format=lucid --no-params
-__ct__11fstreambaseFiPcT1
-fstreambase::fstreambase(int, char *, int)
-fstreambase::fstreambase
-#
---format=lucid --no-params
-__ct__11fstreambaseFv
-fstreambase::fstreambase(void)
-fstreambase::fstreambase
-#
---format=lucid --no-params
-__ct__11smanip_longFPFR3iosl_R3iosl
-smanip_long::smanip_long(ios &(*)(ios &, long), long)
-smanip_long::smanip_long
-#
---format=lucid --no-params
-__ct__11smanip_longFPFO3iosl_O3iosl
-smanip_long::smanip_long(ios &&(*)(ios &&, long), long)
-smanip_long::smanip_long
-#
---format=lucid --no-params
-__ct__11stdiostreamFP4FILE
-stdiostream::stdiostream(FILE *)
-stdiostream::stdiostream
-#
---format=lucid --no-params
-__ct__12strstreambufFPFl_PvPFPv_v
-strstreambuf::strstreambuf(void *(*)(long), void (*)(void *))
-strstreambuf::strstreambuf
-#
---format=lucid --no-params
-__ct__12strstreambufFPUciT1
-strstreambuf::strstreambuf(unsigned char *, int, unsigned char *)
-strstreambuf::strstreambuf
-#
---format=lucid --no-params
-__ct__12strstreambufFPciT1
-strstreambuf::strstreambuf(char *, int, char *)
-strstreambuf::strstreambuf
-#
---format=lucid --no-params
-__ct__12strstreambufFi
-strstreambuf::strstreambuf(int)
-strstreambuf::strstreambuf
-#
---format=lucid --no-params
-__ct__12strstreambufFv
-strstreambuf::strstreambuf(void)
-strstreambuf::strstreambuf
-#
---format=lucid --no-params
-__ct__13strstreambaseFPciT1
-strstreambase::strstreambase(char *, int, char *)
-strstreambase::strstreambase
-#
---format=lucid --no-params
-__ct__3fooFR3foo
-foo::foo(foo &)
-foo::foo
-#
---format=lucid --no-params
-__ct__3fooFO3foo
-foo::foo(foo &&)
-foo::foo
-#
---format=lucid --no-params
-__ct__3fooFi
-foo::foo(int)
-foo::foo
-#
---format=lucid --no-params
-__ct__3fooFiN31
-foo::foo(int, int, int, int)
-foo::foo
-#
---format=lucid --no-params
-__ct__3fooFiR3fooT1T2T1T2
-foo::foo(int, foo &, int, foo &, int, foo &)
-foo::foo
-#
---format=lucid --no-params
-__ct__3fooFiO3fooT1T2T1T2
-foo::foo(int, foo &&, int, foo &&, int, foo &&)
-foo::foo
-#
---format=lucid --no-params
-__ct__3iosFP9streambuf
-ios::ios(streambuf *)
-ios::ios
-#
---format=lucid --no-params
-__ct__7filebufFiPcT1
-filebuf::filebuf(int, char *, int)
-filebuf::filebuf
-#
---format=lucid --no-params
-__ct__7fstreamFiPcT1
-fstream::fstream(int, char *, int)
-fstream::fstream
-#
---format=lucid --no-params
-__ct__7istreamFP9streambuf
-istream::istream(streambuf *)
-istream::istream
-#
---format=lucid --no-params
-__ct__7istreamFP9streambufiP7ostream
-istream::istream(streambuf *, int, ostream *)
-istream::istream
-#
---format=lucid --no-params
-__ct__7istreamFiPcT1
-istream::istream(int, char *, int)
-istream::istream
-#
---format=lucid --no-params
-__ct__7istreamFiT1P7ostream
-istream::istream(int, int, ostream *)
-istream::istream
-#
---format=lucid --no-params
-__ct__7ostreamFP9streambuf
-ostream::ostream(streambuf *)
-ostream::ostream
-#
---format=lucid --no-params
-__ct__7ostreamFiPc
-ostream::ostream(int, char *)
-ostream::ostream
-#
---format=lucid --no-params
-__ct__8ifstreamFiPcT1
-ifstream::ifstream(int, char *, int)
-ifstream::ifstream
-#
---format=lucid --no-params
-__ct__Q23foo3barFv
-foo::bar::bar(void)
-foo::bar::bar
-#
---format=lucid --no-params
-__ct__Q33foo3bar4bellFv
-foo::bar::bell::bell(void)
-foo::bar::bell::bell
-#
---format=lucid --no-params
-__dl__3fooSFPv
-foo::operator delete(void *) static
-foo::operator delete
-#
---format=lucid --no-params
-__dl__FPv
-operator delete(void *)
-operator delete
-#
---format=lucid --no-params
-__dt__10istrstreamFv
-istrstream::~istrstream(void)
-istrstream::~istrstream
-#
---format=lucid --no-params
-__dt__Q23foo3barFv
-foo::bar::~bar(void)
-foo::bar::~bar
-#
---format=lucid --no-params
-__dt__Q33foo3bar4bellFv
-foo::bar::bell::~bell(void)
-foo::bar::bell::~bell
-#
---format=lucid --no-params
-__dv__3fooFR3foo
-foo::operator/(foo &)
-foo::operator/
-#
---format=lucid --no-params
-__dv__F7complexT1
-operator/(complex, complex)
-operator/
-#
---format=lucid --no-params
-__eq__3fooFR3foo
-foo::operator==(foo &)
-foo::operator==
-#
---format=lucid --no-params
-__er__3fooFR3foo
-foo::operator^(foo &)
-foo::operator^
-#
---format=lucid --no-params
-__ge__3fooFR3foo
-foo::operator>=(foo &)
-foo::operator>=
-#
---format=lucid --no-params
-__gt__3fooFR3foo
-foo::operator>(foo &)
-foo::operator>
-#
---format=lucid --no-params
-__le__3fooFR3foo
-foo::operator<=(foo &)
-foo::operator<=
-#
---format=lucid --no-params
-__ls__3fooFR3foo
-foo::operator<<(foo &)
-foo::operator<<
-#
---format=lucid --no-params
-__ls__7ostreamFP9streambuf
-ostream::operator<<(streambuf *)
-ostream::operator<<
-#
---format=lucid --no-params
-__ls__7ostreamFPFR3ios_R3ios
-ostream::operator<<(ios &(*)(ios &))
-ostream::operator<<
-#
---format=lucid --no-params
-__ls__7ostreamFPv
-ostream::operator<<(void *)
-ostream::operator<<
-#
---format=lucid --no-params
-__ls__7ostreamFUi
-ostream::operator<<(unsigned int)
-ostream::operator<<
-#
---format=lucid --no-params
-__ls__7ostreamFUl
-ostream::operator<<(unsigned long)
-ostream::operator<<
-#
---format=lucid --no-params
-__ls__7ostreamFd
-ostream::operator<<(double)
-ostream::operator<<
-#
---format=lucid --no-params
-__ls__7ostreamFf
-ostream::operator<<(float)
-ostream::operator<<
-#
---format=lucid --no-params
-__ls__7ostreamFi
-ostream::operator<<(int)
-ostream::operator<<
-#
---format=lucid --no-params
-__ls__7ostreamFl
-ostream::operator<<(long)
-ostream::operator<<
-#
---format=lucid --no-params
-__ls__FR7ostream7complex
-operator<<(ostream &, complex)
-operator<<
-#
---format=lucid --no-params
-__lt__3fooFR3foo
-foo::operator<(foo &)
-foo::operator<
-#
---format=lucid --no-params
-__md__3fooFR3foo
-foo::operator%(foo &)
-foo::operator%
-#
---format=lucid --no-params
-__mi__3fooFR3foo
-foo::operator-(foo &)
-foo::operator-
-#
---format=lucid --no-params
-__ml__3fooFR3foo
-foo::operator*(foo &)
-foo::operator*
-#
---format=lucid --no-params
-__ml__F7complexT1
-operator*(complex, complex)
-operator*
-#
---format=lucid --no-params
-__mm__3fooFi
-foo::operator--(int)
-foo::operator--
-#
---format=lucid --no-params
-__ne__3fooFR3foo
-foo::operator!=(foo &)
-foo::operator!=
-#
---format=lucid --no-params
-__nt__3fooFv
-foo::operator!(void)
-foo::operator!
-#
---format=lucid --no-params
-__nw__3fooSFi
-foo::operator new(int) static
-foo::operator new
-#
---format=lucid --no-params
-__nw__FUi
-operator new(unsigned int)
-operator new
-#
---format=lucid --no-params
-__nw__FUiPv
-operator new(unsigned int, void *)
-operator new
-#
---format=lucid --no-params
-__oo__3fooFR3foo
-foo::operator||(foo &)
-foo::operator||
-#
---format=lucid --no-params
-__opPc__3fooFv
-foo::operator char *(void)
-foo::operator char *
-#
---format=lucid --no-params
-__opi__3fooFv
-foo::operator int(void)
-foo::operator int
-#
---format=lucid --no-params
-__or__3fooFR3foo
-foo::operator|(foo &)
-foo::operator|
-#
---format=lucid --no-params
-__pl__3fooFR3foo
-foo::operator+(foo &)
-foo::operator+
-#
---format=lucid --no-params
-__pp__3fooFi
-foo::operator++(int)
-foo::operator++
-#
---format=lucid --no-params
-__pt__3fooFv
-foo::operator->(void)
-foo::operator->
-#
---format=lucid --no-params
-__rm__3fooFR3foo
-foo::operator->*(foo &)
-foo::operator->*
-#
---format=lucid --no-params
-__rs__3fooFR3foo
-foo::operator>>(foo &)
-foo::operator>>
-#
---format=lucid --no-params
-__rs__7istreamFP9streambuf
-istream::operator>>(streambuf *)
-istream::operator>>
-#
---format=lucid --no-params
-__rs__7istreamFPFR3ios_R3ios
-istream::operator>>(ios &(*)(ios &))
-istream::operator>>
-#
---format=lucid --no-params
-__rs__7istreamFPFR7istream_R7istream
-istream::operator>>(istream &(*)(istream &))
-istream::operator>>
-#
---format=lucid --no-params
-__rs__7istreamFPUc
-istream::operator>>(unsigned char *)
-istream::operator>>
-#
---format=lucid --no-params
-__rs__7istreamFPc
-istream::operator>>(char *)
-istream::operator>>
-#
---format=lucid --no-params
-__rs__7istreamFRUi
-istream::operator>>(unsigned int &)
-istream::operator>>
-#
---format=lucid --no-params
-__rs__7istreamFRUl
-istream::operator>>(unsigned long &)
-istream::operator>>
-#
---format=lucid --no-params
-__rs__7istreamFRUs
-istream::operator>>(unsigned short &)
-istream::operator>>
-#
---format=lucid --no-params
-__rs__7istreamFRd
-istream::operator>>(double &)
-istream::operator>>
-#
---format=lucid --no-params
-__rs__7istreamFRf
-istream::operator>>(float &)
-istream::operator>>
-#
---format=lucid --no-params
-__rs__7istreamFRi
-istream::operator>>(int &)
-istream::operator>>
-#
---format=lucid --no-params
-__rs__7istreamFRl
-istream::operator>>(long &)
-istream::operator>>
-#
---format=lucid --no-params
-__rs__7istreamFRs
-istream::operator>>(short &)
-istream::operator>>
-#
---format=lucid --no-params
-__rs__FR7istreamR7complex
-operator>>(istream &, complex &)
-operator>>
-#
---format=lucid --no-params
-__vtbl__10istrstream
-istrstream virtual table
-istrstream virtual table
-#
---format=lucid --no-params
-__vtbl__17ostream__iostream__19iostream_withassign
-iostream_withassign::ostream__iostream virtual table
-iostream_withassign::ostream__iostream virtual table
-#
---format=lucid --no-params
-__vtbl__3ios
-ios virtual table
-ios virtual table
-#
---format=lucid --no-params
-__vtbl__3ios__13strstreambase
-strstreambase::ios virtual table
-strstreambase::ios virtual table
-#
---format=lucid --no-params
-abs__F7complex
-abs(complex)
-abs
-#
---format=lucid --no-params
-allocate__9streambufFv
-streambuf::allocate(void)
-streambuf::allocate
-#
---format=lucid --no-params
-attach__11fstreambaseFi
-fstreambase::attach(int)
-fstreambase::attach
-#
---format=lucid --no-params
-bitalloc__3iosSFv
-ios::bitalloc(void) static
-ios::bitalloc
-#
---format=lucid --no-params
-chr__FiT1
-chr(int, int)
-chr
-#
---format=lucid --no-params
-complex_error__FR11c_exception
-complex_error(c_exception &)
-complex_error
-#
---format=lucid --no-params
-complexfunc2__FPFPc_i
-complexfunc2(int (*)(char *))
-complexfunc2
-#
---format=lucid --no-params
-complexfunc3__FPFPFPl_s_i
-complexfunc3(int (*)(short (*)(long *)))
-complexfunc3
-#
---format=lucid --no-params
-complexfunc4__FPFPFPc_s_i
-complexfunc4(int (*)(short (*)(char *)))
-complexfunc4
-#
---format=lucid --no-params
-complexfunc5__FPFPc_PFl_i
-complexfunc5(int (*(*)(char *))(long))
-complexfunc5
-#
---format=lucid --no-params
-complexfunc6__FPFPi_PFl_i
-complexfunc6(int (*(*)(int *))(long))
-complexfunc6
-#
---format=lucid --no-params
-complexfunc7__FPFPFPc_i_PFl_i
-complexfunc7(int (*(*)(int (*)(char *)))(long))
-complexfunc7
-#
---format=lucid --no-params
-complicated_put__7ostreamFc
-ostream::complicated_put(char)
-ostream::complicated_put
-#
---format=lucid --no-params
-conv10__FlPc
-conv10(long, char *)
-conv10
-#
---format=lucid --no-params
-conv16__FUlPc
-conv16(unsigned long, char *)
-conv16
-#
---format=lucid --no-params
-dec__FR3ios
-dec(ios &)
-dec
-#
---format=lucid --no-params
-dec__Fli
-dec(long, int)
-dec
-#
---format=lucid --no-params
-dofield__FP7ostreamPciT2T3
-dofield(ostream *, char *, int, char *, int)
-dofield
-#
---format=lucid --no-params
-flags__3iosFl
-ios::flags(long)
-ios::flags
-#
---format=lucid --no-params
-flags__3iosFv
-ios::flags(void)
-ios::flags
-#
---format=lucid --no-params
-foo__FiN31
-foo(int, int, int, int)
-foo
-#
---format=lucid --no-params
-foo__FiR3fooT1T2T1T2
-foo(int, foo &, int, foo &, int, foo &)
-foo
-#
---format=lucid --no-params
-foo__FiO3fooT1T2T1T2
-foo(int, foo &&, int, foo &&, int, foo &&)
-foo
-#
---format=lucid --no-params
-foo___3barFl
-bar::foo_(long)
-bar::foo_
-#
---format=lucid --no-params
-get__7istreamFPcic
-istream::get(char *, int, char)
-istream::get
-#
---format=lucid --no-params
-get__7istreamFR9streambufc
-istream::get(streambuf &, char)
-istream::get
-#
---format=lucid --no-params
-get_complicated__7istreamFRUc
-istream::get_complicated(unsigned char &)
-istream::get_complicated
-#
---format=lucid --no-params
-get_complicated__7istreamFRc
-istream::get_complicated(char &)
-istream::get_complicated
-#
---format=lucid --no-params
-getline__7istreamFPUcic
-istream::getline(unsigned char *, int, char)
-istream::getline
-#
---format=lucid --no-params
-getline__7istreamFPcic
-istream::getline(char *, int, char)
-istream::getline
-#
---format=lucid --no-params
-ignore__7istreamFiT1
-istream::ignore(int, int)
-istream::ignore
-#
---format=lucid --no-params
-init__12strstreambufFPciT1
-strstreambuf::init(char *, int, char *)
-strstreambuf::init
-#
---format=lucid --no-params
-init__3iosFP9streambuf
-ios::init(streambuf *)
-ios::init
-#
---format=lucid --no-params
-initcount__13Iostream_init
-Iostream_init::initcount
-Iostream_init::initcount
-#
---format=lucid --no-params
-ipfx__7istreamFi
-istream::ipfx(int)
-istream::ipfx
-#
---format=lucid --no-params
-ls_complicated__7ostreamFUc
-ostream::ls_complicated(unsigned char)
-ostream::ls_complicated
-#
---format=lucid --no-params
-ls_complicated__7ostreamFc
-ostream::ls_complicated(char)
-ostream::ls_complicated
-#
---format=lucid --no-params
-overload1arg__FSc
-overload1arg(signed char)
-overload1arg
-#
---format=lucid --no-params
-overload1arg__FUc
-overload1arg(unsigned char)
-overload1arg
-#
---format=lucid --no-params
-overload1arg__FUi
-overload1arg(unsigned int)
-overload1arg
-#
---format=lucid --no-params
-overload1arg__FUl
-overload1arg(unsigned long)
-overload1arg
-#
---format=lucid --no-params
-overload1arg__FUs
-overload1arg(unsigned short)
-overload1arg
-#
---format=lucid --no-params
-overload1arg__Fc
-overload1arg(char)
-overload1arg
-#
---format=lucid --no-params
-overload1arg__Fd
-overload1arg(double)
-overload1arg
-#
---format=lucid --no-params
-overload1arg__Ff
-overload1arg(float)
-overload1arg
-#
---format=lucid --no-params
-overload1arg__Fi
-overload1arg(int)
-overload1arg
-#
---format=lucid --no-params
-overload1arg__Fl
-overload1arg(long)
-overload1arg
-#
---format=lucid --no-params
-overload1arg__Fs
-overload1arg(short)
-overload1arg
-#
---format=lucid --no-params
-overload1arg__Fv
-overload1arg(void)
-overload1arg
-#
---format=lucid --no-params
-overloadargs__FiN21
-overloadargs(int, int, int)
-overloadargs
-#
---format=lucid --no-params
-overloadargs__FiN31
-overloadargs(int, int, int, int)
-overloadargs
-#
---format=lucid --no-params
-overloadargs__FiN41
-overloadargs(int, int, int, int, int)
-overloadargs
-#
---format=lucid --no-params
-overloadargs__FiN51
-overloadargs(int, int, int, int, int, int)
-overloadargs
-#
---format=lucid --no-params
-overloadargs__FiN61
-overloadargs(int, int, int, int, int, int, int)
-overloadargs
-#
---format=lucid --no-params
-overloadargs__FiN71
-overloadargs(int, int, int, int, int, int, int, int)
-overloadargs
-#
---format=lucid --no-params
-overloadargs__FiN81
-overloadargs(int, int, int, int, int, int, int, int, int)
-overloadargs
-#
---format=lucid --no-params
-overloadargs__FiN91
-overloadargs(int, int, int, int, int, int, int, int, int, int)
-overloadargs
-#
---format=lucid --no-params
-overloadargs__FiN91N11
-overloadargs(int, int, int, int, int, int, int, int, int, int, int)
-overloadargs
-#
---format=lucid --no-params
-overloadargs__FiT1
-overloadargs(int, int)
-overloadargs
-#
---format=lucid --no-params
-polar__FdT1
-polar(double, double)
-polar
-#
---format=lucid --no-params
-pow__F7complexT1
-pow(complex, complex)
-pow
-#
---format=lucid --no-params
-pow__F7complexd
-pow(complex, double)
-pow
-#
---format=lucid --no-params
-pow__F7complexi
-pow(complex, int)
-pow
-#
---format=lucid --no-params
-pow__Fd7complex
-pow(double, complex)
-pow
-#
---format=lucid --no-params
-pstart__FPciT2
-pstart(char *, int, int)
-pstart
-#
---format=lucid --no-params
-put__7ostreamFc
-ostream::put(char)
-ostream::put
-#
---format=lucid --no-params
-read__7istreamFPci
-istream::read(char *, int)
-istream::read
-#
---format=lucid --no-params
-resetiosflags__FR3iosl
-resetiosflags(ios &, long)
-resetiosflags
-#
---format=lucid --no-params
-restore_errno__FRi
-restore_errno(int &)
-restore_errno
-#
---format=lucid --no-params
-rs_complicated__7istreamFRUc
-istream::rs_complicated(unsigned char &)
-istream::rs_complicated
-#
---format=lucid --no-params
-rs_complicated__7istreamFRc
-istream::rs_complicated(char &)
-istream::rs_complicated
-#
---format=lucid --no-params
-seekg__7istreamFl8seek_dir
-istream::seekg(long, seek_dir)
-istream::seekg
-#
---format=lucid --no-params
-seekoff__12strstreambufFl8seek_diri
-strstreambuf::seekoff(long, seek_dir, int)
-strstreambuf::seekoff
-#
---format=lucid --no-params
-seekoff__9streambufFlQ2_3ios12ios_seek_diri
-streambuf::seekoff(long, ios::ios_seek_dir, int)
-streambuf::seekoff
-#
---format=lucid --no-params
-seekpos__9streambufFli
-streambuf::seekpos(long, int)
-streambuf::seekpos
-#
---format=lucid --no-params
-set_new_handler__FPFv_v
-set_new_handler(void (*)(void))
-set_new_handler
-#
---format=lucid --no-params
-setb__9streambufFPcT1i
-streambuf::setb(char *, char *, int)
-streambuf::setb
-#
---format=lucid --no-params
-setb__FR3iosi
-setb(ios &, int)
-setb
-#
---format=lucid --no-params
-setbuf__11fstreambaseFPci
-fstreambase::setbuf(char *, int)
-fstreambase::setbuf
-#
---format=lucid --no-params
-setbuf__9streambufFPUci
-streambuf::setbuf(unsigned char *, int)
-streambuf::setbuf
-#
---format=lucid --no-params
-setbuf__9streambufFPciT2
-streambuf::setbuf(char *, int, int)
-streambuf::setbuf
-#
---format=lucid --no-params
-setf__3iosFlT1
-ios::setf(long, long)
-ios::setf
-#
---format=lucid --no-params
-setfill__FR3iosi
-setfill(ios &, int)
-setfill
-#
---format=lucid --no-params
-setg__9streambufFPcN21
-streambuf::setg(char *, char *, char *)
-streambuf::setg
-#
---format=lucid --no-params
-setp__9streambufFPcT1
-streambuf::setp(char *, char *)
-streambuf::setp
-#
---format=lucid --no-params
-tie__3iosFP7ostream
-ios::tie(ostream *)
-ios::tie
-#
---format=lucid --no-params
-uconv10__FUlPc
-uconv10(unsigned long, char *)
-uconv10
-#
---format=lucid --no-params
-xget__7istreamFPc
-istream::xget(char *)
-istream::xget
-#
---format=lucid --no-params
-xsgetn__9streambufFPci
-streambuf::xsgetn(char *, int)
-streambuf::xsgetn
-#
---format=arm --no-params
-__dt__21T5__pt__11_PFiPPdPv_iFv
-T5<int (*)(int, double **, void *)>::~T5(void)
-T5<int (*)(int, double **, void *)>::~T5
-#
---format=arm --no-params
-__ct__1cFi
-c::c(int)
-c::c
-#
---format=arm --no-params
-__dt__11T5__pt__2_iFv
-T5<int>::~T5(void)
-T5<int>::~T5
-#
---format=arm --no-params
-__dt__11T5__pt__2_cFv
-T5<char>::~T5(void)
-T5<char>::~T5
-#
---format=arm --no-params
-__ct__2T2Fi
-T2::T2(int)
-T2::T2
-#
---format=arm --no-params
-__dt__2T1Fv
-T1::~T1(void)
-T1::~T1
-#
---format=arm --no-params
-__dt__12T5__pt__3_1xFv
-T5<x>::~T5(void)
-T5<x>::~T5
-#
---format=arm --no-params
-__dt__17T5__pt__8_PFcPv_iFv
-T5<int (*)(char, void *)>::~T5(void)
-T5<int (*)(char, void *)>::~T5
-#
---format=arm --no-params
-__ct__21T5__pt__11_PFiPPdPv_iFi
-T5<int (*)(int, double **, void *)>::T5(int)
-T5<int (*)(int, double **, void *)>::T5
-#
---format=arm --no-params
-__amd__FR2T2i
-operator%=(T2 &, int)
-operator%=
-#
---format=arm --no-params
-__adv__FR2T2i
-operator/=(T2 &, int)
-operator/=
-#
---format=arm --no-params
-__amu__FR2T2i
-operator*=(T2 &, int)
-operator*=
-#
---format=arm --no-params
-__ami__FR2T2i
-operator-=(T2 &, int)
-operator-=
-#
---format=arm --no-params
-__apl__FR2T2i
-operator+=(T2 &, int)
-operator+=
-#
---format=arm --no-params
-__nw__2T1SFUi
-T1::operator new(unsigned int) static
-T1::operator new
-#
---format=arm --no-params
-__dl__2T1SFPv
-T1::operator delete(void *) static
-T1::operator delete
-#
---format=arm --no-params
-put__2T7SFi
-T7::put(int) static
-T7::put
-#
---format=arm --no-params
-__dl__12T5__pt__3_1xSFPv
-T5<x>::operator delete(void *) static
-T5<x>::operator delete
-#
---format=arm --no-params
-h__FUc
-h(unsigned char)
-h
-#
---format=arm --no-params
-f__Fic
-f(int, char)
-f
-#
---format=arm --no-params
-h__FUi
-h(unsigned int)
-h
-#
---format=arm --no-params
-h__Fci
-h(char, int)
-h
-#
---format=arm --no-params
-h__FUl
-h(unsigned long)
-h
-#
---format=arm --no-params
-h__Fcl
-h(char, long)
-h
-#
---format=arm --no-params
-h__FUs
-h(unsigned short)
-h
-#
---format=arm --no-params
-h__Fcs
-h(char, short)
-h
-#
---format=arm --no-params
-X__12T5__pt__3_1x
-T5<x>::X
-T5<x>::X
-#
---format=arm --no-params
-__ct__11T5__pt__2_iFi
-T5<int>::T5(int)
-T5<int>::T5
-#
---format=arm --no-params
-__ct__11T5__pt__2_cFi
-T5<char>::T5(int)
-T5<char>::T5
-#
---format=arm --no-params
-h__FcT1
-h(char, char)
-h
-#
---format=arm --no-params
-f__Ficd
-f(int, char, double)
-f
-#
---format=arm --no-params
-__dl__17T5__pt__8_PFcPv_iSFPv
-T5<int (*)(char, void *)>::operator delete(void *) static
-T5<int (*)(char, void *)>::operator delete
-#
---format=arm --no-params
-X__17T5__pt__8_PFcPv_i
-T5<int (*)(char, void *)>::X
-T5<int (*)(char, void *)>::X
-#
---format=arm --no-params
-__ct__12T5__pt__3_1xFi
-T5<x>::T5(int)
-T5<x>::T5
-#
---format=arm --no-params
-__dl__21T5__pt__11_PFiPPdPv_iSFPv
-T5<int (*)(int, double **, void *)>::operator delete(void *) static
-T5<int (*)(int, double **, void *)>::operator delete
-#
---format=arm --no-params
-__std__foo
-global destructors keyed to foo
-global destructors keyed to foo
-#
---format=arm --no-params
-__sti__bar
-global constructors keyed to bar
-global constructors keyed to bar
-#
---format=arm --no-params
-f__FicdPcPFci_v
-f(int, char, double, char *, void (*)(char, int))
-f
-#
---format=arm --no-params
-f__FicdPcPFic_v
-f(int, char, double, char *, void (*)(int, char))
-f
-#
---format=arm --no-params
-get__2T7SFv
-T7::get(void) static
-T7::get
-#
---format=arm --no-params
-X__21T5__pt__11_PFiPPdPv_i
-T5<int (*)(int, double **, void *)>::X
-T5<int (*)(int, double **, void *)>::X
-#
---format=arm --no-params
-__dl__11T5__pt__2_iSFPv
-T5<int>::operator delete(void *) static
-T5<int>::operator delete
-#
---format=arm --no-params
-__dl__11T5__pt__2_cSFPv
-T5<char>::operator delete(void *) static
-T5<char>::operator delete
-#
---format=arm --no-params
-h__Fc
-h(char)
-h
-#
---format=arm --no-params
-h__Fd
-h(double)
-h
-#
---format=arm --no-params
-h__Ff
-h(float)
-h
-#
---format=arm --no-params
-h__Fi
-h(int)
-h
-#
---format=arm --no-params
-f__Fi
-f(int)
-f
-#
---format=arm --no-params
-h__Fl
-h(long)
-h
-#
---format=arm --no-params
-h__Fs
-h(short)
-h
-#
---format=arm --no-params
-X__11T5__pt__2_c
-T5<char>::X
-T5<char>::X
-#
---format=arm --no-params
-X__11T5__pt__2_i
-T5<int>::X
-T5<int>::X
-#
---format=arm --no-params
-__ct__17T5__pt__8_PFcPv_iFi
-T5<int (*)(char, void *)>::T5(int)
-T5<int (*)(char, void *)>::T5
-#
---format=arm --no-params
-f__FicdPc
-f(int, char, double, char *)
-f
-#
---format=arm --no-params
-__nw__FUi
-operator new(unsigned int)
-operator new
-#
---format=arm --no-params
-__ct__Q3_2T11a1bSFi
-T1::a::b::b(int) static
-T1::a::b::b
-#
---format=arm --no-params
-__dt__Q3_2T11a1bSFi
-T1::a::b::~b(int) static
-T1::a::b::~b
-#
---format=arm --no-params
-put__Q3_2T11a1bSFi
-T1::a::b::put(int) static
-T1::a::b::put
-#
---format=arm --no-params
-get__Q2_2T11aSFv
-T1::a::get(void) static
-T1::a::get
-#
---format=arm --no-params
-put__2T1SFi
-T1::put(int) static
-T1::put
-#
---format=arm --no-params
-put__Q5_2T11a1b1c1dSFi
-T1::a::b::c::d::put(int) static
-T1::a::b::c::d::put
-#
---format=arm --no-params
-get__Q4_2T11a1b1cSFv
-T1::a::b::c::get(void) static
-T1::a::b::c::get
-#
---format=arm --no-params
-put__Q2_2T11aSFi
-T1::a::put(int) static
-T1::a::put
-#
---format=arm --no-params
-put__Q4_2T11a1b1cSFi
-T1::a::b::c::put(int) static
-T1::a::b::c::put
-#
---format=arm --no-params
-get__Q3_2T11a1bSFv
-T1::a::b::get(void) static
-T1::a::b::get
-#
---format=arm --no-params
-get__2T1SFv
-T1::get(void) static
-T1::get
-#
---format=arm --no-params
-get__Q5_2T11a1b1c1dSFv
-T1::a::b::c::d::get(void) static
-T1::a::b::c::d::get
-#
---format=arm --no-params
-__dt__11T1__pt__2_cFv
-T1<char>::~T1(void)
-T1<char>::~T1
-#
---format=arm --no-params
-__dt__12T1__pt__3_1tFv
-T1<t>::~T1(void)
-T1<t>::~T1
-#
---format=arm --no-params
-__dl__12T1__pt__3_1tSFPv
-T1<t>::operator delete(void *) static
-T1<t>::operator delete
-#
---format=arm --no-params
-__ct__11T1__pt__2_cFi
-T1<char>::T1(int)
-T1<char>::T1
-#
---format=arm --no-params
-__ct__11T1__pt__2_cFv
-T1<char>::T1(void)
-T1<char>::T1
-#
---format=arm --no-params
-__ct__12T1__pt__3_1tFi
-T1<t>::T1(int)
-T1<t>::T1
-#
---format=arm --no-params
-__ct__12T1__pt__3_1tFv
-T1<t>::T1(void)
-T1<t>::T1
-#
---format=arm --no-params
-__dl__11T1__pt__2_cSFPv
-T1<char>::operator delete(void *) static
-T1<char>::operator delete
-#
---format=arm --no-params
-bar__3fooFPv
-foo::bar(void *)
-foo::bar
-#
---format=arm --no-params
-bar__3fooCFPv
-foo::bar(void *) const
-foo::bar
-#
---format=arm --no-params
-__eq__3fooFR3foo
-foo::operator==(foo &)
-foo::operator==
-#
---format=arm --no-params
-__eq__3fooCFR3foo
-foo::operator==(foo &) const
-foo::operator==
-#
---format=arm --no-params
-elem__15vector__pt__2_dFi
-vector<double>::elem(int)
-vector<double>::elem
-#
---format=arm --no-params
-elem__15vector__pt__2_iFi
-vector<int>::elem(int)
-vector<int>::elem
-#
---format=arm --no-params
-__ct__15vector__pt__2_dFi
-vector<double>::vector(int)
-vector<double>::vector
-#
---format=arm --no-params
-__ct__15vector__pt__2_iFi
-vector<int>::vector(int)
-vector<int>::vector
-#
---format=arm --no-params
-__ct__25DListNode__pt__9_R6RLabelFR6RLabelP25DListNode__pt__9_R6RLabelT2
-DListNode<RLabel &>::DListNode(RLabel &, DListNode<RLabel &> *, DListNode<RLabel &> *)
-DListNode<RLabel &>::DListNode
-#
---format=arm --no-params
-__ct__25DListNode__pt__9_O6RLabelFO6RLabelP25DListNode__pt__9_O6RLabelT2
-DListNode<RLabel &&>::DListNode(RLabel &&, DListNode<RLabel &&> *, DListNode<RLabel &&> *)
-DListNode<RLabel &&>::DListNode
-#
---format=arm --no-params
-bar__3fooFiT16FooBar
-foo::bar(int, int, FooBar)
-foo::bar
-#
---format=arm --no-params
-bar__3fooFPiN51PdN37PcN211T1iN215
-foo::bar(int *, int *, int *, int *, int *, int *, double *, double *, double *, double *, char *, char *, char *, int *, int, int, int)
-foo::bar
-#
---format=hp --no-params
-__amd__FR2T2i
-operator%=(T2 &, int)
-operator%=
-#
---format=hp --no-params
-__adv__FR2T2i
-operator/=(T2 &, int)
-operator/=
-#
---format=hp --no-params
-__amu__FR2T2i
-operator*=(T2 &, int)
-operator*=
-#
---format=hp --no-params
-__ami__FR2T2i
-operator-=(T2 &, int)
-operator-=
-#
---format=hp --no-params
-__apl__FR2T2i
-operator+=(T2 &, int)
-operator+=
-#
---format=hp --no-params
-__nw__2T1SFUi
-T1::operator new(unsigned int) static
-T1::operator new
-#
---format=hp --no-params
-__dl__2T1SFPv
-T1::operator delete(void *) static
-T1::operator delete
-#
---format=hp --no-params
-put__2T7SFi
-T7::put(int) static
-T7::put
-#
---format=hp --no-params
-h__FUc
-h(unsigned char)
-h
-#
---format=hp --no-params
-f__Fic
-f(int, char)
-f
 #
---format=hp --no-params
-h__FUi
-h(unsigned int)
-h
-#
---format=hp --no-params
-h__Fci
-h(char, int)
-h
-#
---format=hp --no-params
-h__FUl
-h(unsigned long)
-h
-#
---format=hp --no-params
-h__Fcl
-h(char, long)
-h
-#
---format=hp --no-params
-h__FUs
-h(unsigned short)
-h
-#
---format=hp --no-params
-h__Fcs
-h(char, short)
-h
-#
---format=hp --no-params
-h__FcT1
-h(char, char)
-h
-#
---format=hp --no-params
-f__Ficd
-f(int, char, double)
-f
-#
---format=hp --no-params
-f__FicdPcPFci_v
-f(int, char, double, char *, void (*)(char, int))
-f
-#
---format=hp --no-params
-f__FicdPcPFic_v
-f(int, char, double, char *, void (*)(int, char))
-f
-#
---format=hp --no-params
-get__2T7SFv
-T7::get(void) static
-T7::get
-#
---format=hp --no-params
-h__Fc
-h(char)
-h
-#
---format=hp --no-params
-h__Fd
-h(double)
-h
-#
---format=hp --no-params
-h__Ff
-h(float)
-h
-#
---format=hp --no-params
-h__Fi
-h(int)
-h
-#
---format=hp --no-params
-f__Fi
-f(int)
-f
-#
---format=hp --no-params
-h__Fl
-h(long)
-h
+# Tests integer overflow problem PR70492
+
+__vt_90000000000cafebabe
+__vt_90000000000cafebabe
 #
---format=hp --no-params
-h__Fs
-h(short)
-h
+# Tests write access violation PR70498
+
+_Z80800000000000000000000
+_Z80800000000000000000000
 #
---format=hp --no-params
-f__FicdPc
-f(int, char, double, char *)
-f
+# Tests write access violation PR70926
+
+0__Ot2m02R5T0000500000
+0__Ot2m02R5T0000500000
 #
---format=hp --no-params
-__nw__FUi
-operator new(unsigned int)
-operator new
-#
---format=hp --no-params
-__ct__Q3_2T11a1bSFi
-T1::a::b::b(int) static
-T1::a::b::b
-#
---format=hp --no-params
-__dt__Q3_2T11a1bSFi
-T1::a::b::~b(int) static
-T1::a::b::~b
-#
---format=hp --no-params
-put__Q3_2T11a1bSFi
-T1::a::b::put(int) static
-T1::a::b::put
-#
---format=hp --no-params
-get__Q2_2T11aSFv
-T1::a::get(void) static
-T1::a::get
-#
---format=hp --no-params
-put__2T1SFi
-T1::put(int) static
-T1::put
-#
---format=hp --no-params
-put__Q5_2T11a1b1c1dSFi
-T1::a::b::c::d::put(int) static
-T1::a::b::c::d::put
-#
---format=hp --no-params
-get__Q4_2T11a1b1cSFv
-T1::a::b::c::get(void) static
-T1::a::b::c::get
-#
---format=hp --no-params
-put__Q2_2T11aSFi
-T1::a::put(int) static
-T1::a::put
-#
---format=hp --no-params
-put__Q4_2T11a1b1cSFi
-T1::a::b::c::put(int) static
-T1::a::b::c::put
-#
---format=hp --no-params
-get__Q3_2T11a1bSFv
-T1::a::b::get(void) static
-T1::a::b::get
-#
---format=hp --no-params
-get__2T1SFv
-T1::get(void) static
-T1::get
-#
---format=hp --no-params
-get__Q5_2T11a1b1c1dSFv
-T1::a::b::c::d::get(void) static
-T1::a::b::c::d::get
-#
---format=hp --no-params
-bar__3fooFPv
-foo::bar(void *)
-foo::bar
-#
---format=hp --no-params
-bar__3fooCFPv
-foo::bar(void *) const
-foo::bar
-#
---format=hp --no-params
-__eq__3fooFR3foo
-foo::operator==(foo &)
-foo::operator==
-#
---format=hp --no-params
-__eq__3fooCFR3foo
-foo::operator==(foo &) const
-foo::operator==
-#
---format=hp --no-params
-bar__3fooFiT16FooBar
-foo::bar(int, int, FooBar)
-foo::bar
-#
---format=hp --no-params
-bar__3fooFPiN51PdN37PcN211T1iN215
-foo::bar(int *, int *, int *, int *, int *, int *, double *, double *, double *, double *, char *, char *, char *, int *, int, int, int)
-foo::bar
-#
---format=hp --no-params
-__dt__2T5XTPFiPPdPv_i__Fv
-T5<int (*)(int, double **, void *)>::~T5(void)
-T5<int (*)(int, double **, void *)>::~T5
-#
---format=hp --no-params
-__ct__1cFi
-c::c(int)
-c::c
-#
---format=hp --no-params
-__dt__2T5XTi__Fv
-T5<int>::~T5(void)
-T5<int>::~T5
-#
---format=hp --no-params
-__dt__2T5XTc__Fv
-T5<char>::~T5(void)
-T5<char>::~T5
-#
---format=hp --no-params
-__ct__2T2Fi
-T2::T2(int)
-T2::T2
-#
---format=hp --no-params
-__dt__2T1Fv
-T1::~T1(void)
-T1::~T1
-#
---format=hp --no-params
-__dt__2T5XT1x__Fv
-T5<x>::~T5(void)
-T5<x>::~T5
-#
---format=hp --no-params
-__dt__2T5XTPFcPv_i__Fv
-T5<int (*)(char, void *)>::~T5(void)
-T5<int (*)(char, void *)>::~T5
-#
---format=hp --no-params
-__ct__2T5XTPFiPPdPv_i__Fi
-T5<int (*)(int, double **, void *)>::T5(int)
-T5<int (*)(int, double **, void *)>::T5
-#
---format=hp --no-params
-__dl__2T5XT1x__SFPv
-T5<x>::operator delete(void *) static
-T5<x>::operator delete
-#
---format=hp --no-params
-X__2T5XT1x
-T5<x>::X
-T5<x>::X
-#
---format=hp --no-params
-__ct__2T5XTi__Fi
-T5<int>::T5(int)
-T5<int>::T5
-#
---format=hp --no-params
-__ct__2T5XTc__Fi
-T5<char>::T5(int)
-T5<char>::T5
-#
---format=hp --no-params
-__dl__2T5XTPFcPv_i__SFPv
-T5<int (*)(char, void *)>::operator delete(void *) static
-T5<int (*)(char, void *)>::operator delete
-#
---format=hp --no-params
-X__2T5XTPFcPv_i
-T5<int (*)(char, void *)>::X
-T5<int (*)(char, void *)>::X
-#
---format=hp --no-params
-__ct__2T5XT1x__Fi
-T5<x>::T5(int)
-T5<x>::T5
-#
---format=hp --no-params
-__dl__2T5XTPFiPPdPv_i__SFPv
-T5<int (*)(int, double **, void *)>::operator delete(void *) static
-T5<int (*)(int, double **, void *)>::operator delete
-#
---format=hp --no-params
-X__2T5XTPFiPPdPv_i
-T5<int (*)(int, double **, void *)>::X
-T5<int (*)(int, double **, void *)>::X
-#
---format=hp --no-params
-__dl__2T5XTi__SFPv
-T5<int>::operator delete(void *) static
-T5<int>::operator delete
-#
---format=hp --no-params
-__dl__2T5XTc__SFPv
-T5<char>::operator delete(void *) static
-T5<char>::operator delete
-#
---format=hp --no-params
-X__2T5XTc
-T5<char>::X
-T5<char>::X
-#
---format=hp --no-params
-X__2T5XTi
-T5<int>::X
-T5<int>::X
-#
---format=hp --no-params
-__ct__2T5XTPFcPv_i__Fi
-T5<int (*)(char, void *)>::T5(int)
-T5<int (*)(char, void *)>::T5
-#
---format=hp --no-params
-__dt__2T1XTc__Fv
-T1<char>::~T1(void)
-T1<char>::~T1
-#
---format=hp --no-params
-__dt__2T1XT1t__Fv
-T1<t>::~T1(void)
-T1<t>::~T1
-#
---format=hp --no-params
-__dl__2T1XT1t__SFPv
-T1<t>::operator delete(void *) static
-T1<t>::operator delete
-#
---format=hp --no-params
-__ct__2T1XTc__Fi
-T1<char>::T1(int)
-T1<char>::T1
-#
---format=hp --no-params
-__ct__2T1XTc__Fv
-T1<char>::T1(void)
-T1<char>::T1
-#
---format=hp --no-params
-__ct__2T1XT1t__Fi
-T1<t>::T1(int)
-T1<t>::T1
-#
---format=hp --no-params
-__ct__2T1XT1t__Fv
-T1<t>::T1(void)
-T1<t>::T1
-#
---format=hp --no-params
-__dl__2T1XTc__SFPv
-T1<char>::operator delete(void *) static
-T1<char>::operator delete
-#
---format=hp --no-params
-elem__6vectorXTd__Fi
-vector<double>::elem(int)
-vector<double>::elem
-#
---format=hp --no-params
-elem__6vectorXTi__Fi
-vector<int>::elem(int)
-vector<int>::elem
-#
---format=hp --no-params
-__ct__6vectorXTd__Fi
-vector<double>::vector(int)
-vector<double>::vector
-#
---format=hp --no-params
-__ct__6vectorXTi__Fi
-vector<int>::vector(int)
-vector<int>::vector
-#
---format=hp --no-params
-__ct__9DListNodeXTR6RLabel__FR6RLabelP9DListNodeXTR6RLabel_T2
-DListNode<RLabel &>::DListNode(RLabel &, DListNode<RLabel &> *, DListNode<RLabel &> *)
-DListNode<RLabel &>::DListNode
-#
---format=hp --no-params
-__ct__9DListNodeXTO6RLabel__FO6RLabelP9DListNodeXTO6RLabel_T2
-DListNode<RLabel &&>::DListNode(RLabel &&, DListNode<RLabel &&> *, DListNode<RLabel &&> *)
-DListNode<RLabel &&>::DListNode
-#
---format=hp --no-params
-elem__6vectorXTiUP34__Fi
-vector<int,34U>::elem(int)
-vector<int,34U>::elem
-#
---format=hp --no-params
-elem__6vectorXUP2701Td__Fi
-vector<2701U,double>::elem(int)
-vector<2701U,double>::elem
-#
---format=hp --no-params
-elem__6vectorXTiSP334__Fi
-vector<int,334>::elem(int)
-vector<int,334>::elem
-#
---format=hp --no-params
-elem__6vectorXTiSN67__Fi
-vector<int,-67>::elem(int)
-vector<int,-67>::elem
-#
---format=hp --no-params
-elem__6vectorXTiSM__SCFPPd
-vector<int,-2147483648>::elem(double **) static const
-vector<int,-2147483648>::elem
-#
---format=hp --no-params
-elem__6vectorXTiSN67UP4000TRs__Fi
-vector<int,-67,4000U,short &>::elem(int)
-vector<int,-67,4000U,short &>::elem
-#
---format=hp --no-params
-elem__6vectorXTiSN67UP4000TOs__Fi
-vector<int,-67,4000U,short &&>::elem(int)
-vector<int,-67,4000U,short &&>::elem
-#
---format=hp --no-params
-elem__6vectorXTiSN67TRdTFPv_i__Fi
-vector<int,-67,double &,int (void *)>::elem(int)
-vector<int,-67,double &,int (void *)>::elem
-#
---format=hp --no-params
-elem__6vectorXTiSN67TOdTFPv_i__Fi
-vector<int,-67,double &&,int (void *)>::elem(int)
-vector<int,-67,double &&,int (void *)>::elem
-#
---format=hp --no-params
-X__6vectorXTiSN67TdTPvUP5TRs
-vector<int,-67,double,void *,5U,short &>::X
-vector<int,-67,double,void *,5U,short &>::X
-#
---format=hp --no-params
-X__6vectorXTiSN67TdTPvUP5TOs
-vector<int,-67,double,void *,5U,short &&>::X
-vector<int,-67,double,void *,5U,short &&>::X
-#
---format=hp --no-params
-elem__6vectorXTiA3foo__Fi
-vector<int,&foo>::elem(int)
-vector<int,&foo>::elem
-#
---format=hp --no-params
-elem__6vectorXTiA3fooTPvA5Label__FiPPvT2
-vector<int,&foo,void *,&Label>::elem(int, void **, void **)
-vector<int,&foo,void *,&Label>::elem
-#
---format=hp --no-params
-elem__6vectorXTiSN42A3foo__Fi
-vector<int,-42,&foo>::elem(int)
-vector<int,-42,&foo>::elem
-#
---format=hp --no-params
-__ct__2T5XTPFcPv_i__Fi_2
-T5<int (*)(char, void *)>::T5(int)
-T5<int (*)(char, void *)>::T5
-#
---format=hp --no-params
-__ct__2T5XTPFcPv_i__Fi_19
-T5<int (*)(char, void *)>::T5(int)
-T5<int (*)(char, void *)>::T5
-#
---format=hp --no-params
-f__FicdPcPFci_v_34
-f(int, char, double, char *, void (*)(char, int))
-f
+
+0__GT50000000000_
+0__GT50000000000_
 #
---format=hp --no-params
-spec__13Spec<#1,#1.*>XTiTPi_FPi
-Spec<int,int *>::spec(int *)
-Spec<int,int *>::spec
-#
---format=hp --no-params
-spec__16Spec<#1,#1.&,#1>XTiTRiTi_FPi
-Spec<int,int &,int>::spec(int *)
-Spec<int,int &,int>::spec
-#
---format=hp --no-params
-spec__17Spec<#1,#1.&&,#1>XTiTOiTi_FPi
-Spec<int,int &&,int>::spec(int *)
-Spec<int,int &&,int>::spec
-#
---format=hp --no-params
-add__XTc_FcT1
-add<char>(char, char)
-add<char>
-#
---format=hp --no-params
-add__XTcSP9A5label_FcPPlT1
-add<char,9,&label>(char, long **, char)
-add<char,9,&label>
-#
---format=hp --no-params
-add__XTPfTFPd_f_FcT1
-add<float *,float (double *)>(char, char)
-add<float *,float (double *)>
-#
---format=hp --no-params
-unLink__12basic_stringXTcT18string_char_traitsXTc_T9allocator_Fv
-basic_string<char,string_char_traits<char>,allocator>::unLink(void)
-basic_string<char,string_char_traits<char>,allocator>::unLink
-#
-# A regression test with no args.  This used to cause a segv.
 
-_Utf390_1__1_9223372036854775807__9223372036854775
-_Utf390_1__1_9223372036854775807__9223372036854775
-#
---format=gnu --no-params
-call__H1Z4Test_RX01_t1C2ZX01PMX01FPX01i_vQ2X016output
-C<Test, Test::output> call<Test>(Test &)
-C<Test, Test::output> call<Test>
-#
---format=gnu --no-params
-call__H1Z4Test_OX01_t1C2ZX01PMX01FPX01i_vQ2X016output
-C<Test, Test::output> call<Test>(Test &&)
-C<Test, Test::output> call<Test>
-#
---format=gnu --no-params
-fn__FPQ21n1cPMQ21n1cFPQ21n1c_i
-fn(n::c *, int (n::c::*)(n::c *))
-fn
-#
---format=gnu --no-params
-f__FGt3Bar1i2G1i
-f(Bar<2>, i)
-f
+__t2m05B500000000000000000_
+__t2m05B500000000000000000_
+##
+## Tests stack overflow PR71696
 #
---format=gnu --no-params
-f__FGt3Bar1i21i
-f(Bar<21>, int)
-f
+#__10%0__S4_0T0T0
+#%0<>::%0(%0<>)
+# Could crash
+
+_
+_
+# Could crash
+
+_vt
+_vt
+# Could crash
+
+_$_1Acitz
+_$_1Acitz
+# Could crash
+
+_$_H1R
+_$_H1R
+# Could crash
+
+_Q8ccQ4M2e.
+_Q8ccQ4M2e.
 #
---format=gnu --no-params
-f__FGt3Bar1i2G4XY_t
-f(Bar<2>, XY_t)
-f
+# demangler/80513 Test for bogus characters after __thunk_
+
+__thunk_16a_$_1x
+__thunk_16a_$_1x
 #
---format=gnu --no-params
-foo__H1Zt2TA2ZRCiZt2NA1Ui9_X01_i
-int foo<TA<int const &, NA<9> > >(TA<int const &, NA<9> >)
-int foo<TA<int const &, NA<9> > >
-#
---format=gnu --no-params
-foo__H1Zt2TA2ZOCiZt2NA1Ui9_X01_i
-int foo<TA<int const &&, NA<9> > >(TA<int const &&, NA<9> >)
-int foo<TA<int const &&, NA<9> > >
-#
---format=gnu --no-params
-foo__H1Zt2TA2ZcZt2NA1Ui20_X01_i
-int foo<TA<char, NA<20> > >(TA<char, NA<20> >)
-int foo<TA<char, NA<20> > >
-#
---format=gnu --no-params
-foo__H1Zt2TA2ZiZt8N___A___1Ui99_X01_i
-int foo<TA<int, N___A___<99> > >(TA<int, N___A___<99> >)
-int foo<TA<int, N___A___<99> > >
-#
---format=gnu --no-params
-foo__H1Zt2TA2ZRCiZt2NA1im1_X01_i
-int foo<TA<int const &, NA<-1> > >(TA<int const &, NA<-1> >)
-int foo<TA<int const &, NA<-1> > >
-#
---format=gnu --no-params
-foo__H1Zt2TA2ZRCiZt2NA1im9_X01_i
-int foo<TA<int const &, NA<-9> > >(TA<int const &, NA<-9> >)
-int foo<TA<int const &, NA<-9> > >
-#
---format=gnu --no-params
-foo__H1Zt2TA2ZcZt2NA1i_m20__X01_i
-int foo<TA<char, NA<-20> > >(TA<char, NA<-20> >)
-int foo<TA<char, NA<-20> > >
-#
---format=gnu --no-params
-foo__H1Zt2TA2ZcZt2NA1im1_X01_i
-int foo<TA<char, NA<-1> > >(TA<char, NA<-1> >)
-int foo<TA<char, NA<-1> > >
-#
---format=gnu --no-params
-foo__H1Zt2TA2ZiZt4N__A1im9_X01_i
-int foo<TA<int, N__A<-9> > >(TA<int, N__A<-9> >)
-int foo<TA<int, N__A<-9> > >
-#
---format=gnu --no-params
-foo__H1Zt2TA2ZiZt4N__A1i_m99__X01_i
-int foo<TA<int, N__A<-99> > >(TA<int, N__A<-99> >)
-int foo<TA<int, N__A<-99> > >
-#
---format=gnu --no-params
-__opi__t2TA2ZiZt4N__A1i9
-TA<int, N__A<9> >::operator int(void)
-TA<int, N__A<9> >::operator int
-#
---format=gnu --no-params
-__opi__t2TA2ZiZt8N___A___1i_m99_
-TA<int, N___A___<-99> >::operator int(void)
-TA<int, N___A___<-99> >::operator int
-#
---format=gnu --no-params
-foo___bar__baz_____H1Zt2TA2ZiZt8N___A___1i99_X01_i
-int foo___bar__baz___<TA<int, N___A___<99> > >(TA<int, N___A___<99> >)
-int foo___bar__baz___<TA<int, N___A___<99> > >
-#
---format=gnu --no-params
-foo__bar___foobar_____t2TA2ZiZt8N___A___1i_m99_
-TA<int, N___A___<-99> >::foo__bar___foobar___(void)
-TA<int, N___A___<-99> >::foo__bar___foobar___
-#
---format=gnu --no-params
-foo__bar___foobar_____t2TA2ZiZt4N__A1i9
-TA<int, N__A<9> >::foo__bar___foobar___(void)
-TA<int, N__A<9> >::foo__bar___foobar___
-#
---format=gnu --no-params
-__tfP8sockaddr
-sockaddr * type_info function
-sockaddr * type_info function
-#
---format=gnu --no-params
-__tfPQ25libcwt16option_event_tct1Z12burst_app_ct
-libcw::option_event_tct<burst_app_ct> * type_info function
-libcw::option_event_tct<burst_app_ct> * type_info function
-#
---format=gnu --no-params
-__tiP8sockaddr
-sockaddr * type_info node
-sockaddr * type_info node
-#
---format=gnu --no-params
-__tiPQ25libcwt16option_event_tct1Z12burst_app_ct
-libcw::option_event_tct<burst_app_ct> * type_info node
-libcw::option_event_tct<burst_app_ct> * type_info node
-#
---format=gnu --no-params
-_27_GLOBAL_.N.__12burst_app_ct.app_instance
-{anonymous}::app_instance
-{anonymous}::app_instance
-#
---format=gnu --no-params
-_26_GLOBAL_$N$_tmp_n.iilg4Gya$app_instance
-{anonymous}::app_instance
-{anonymous}::app_instance
+# demangler/80513 Test for overflow in consume_count
+
+__thunk_4294967297__$_1x
+__thunk_4294967297__$_1x
 #
 --format=gnu-v3 --no-params
 _Z3fo5n
@@ -3368,7 +117,7 @@ java.util.Map$Entry.class$
 _ZN3org7eclipse3cdt5debug8internal4core5model9CVariable6sizeof$Ev
 org.eclipse.cdt.debug.internal.core.model.CVariable.sizeof()
 #
---format=hp --no-params
+--format=auto --no-params
 _Utf58_0_1__1_2147483647__2147483648
 _Utf58_0_1__1_2147483647__2147483648
 _Utf58_0_1__1_2147483647__2147483648
@@ -3904,24 +653,6 @@ _ZNSdD1Ev
 _ZNSdD1Ev
 2
 #
-# This caused an infinite loop.
-#
-# This is generated by an EDG compiler (kcc 4.0).  To demangle it
-# correctly, I believe that we have to understand that the J37J deep
-# in the string somehow refers back to the type starting 37 characters
-# in from some starting point, so that it winds up being the type
-# starting with 41THandle....  However, lacking a spec for EDG
-# demangling, it's hard to implement this.
-#
-# In the meantime, this symbol can be successfully demangled in GNU
-# mode.  Of course the result is more or less nonsense, but an older
-# version of g++ would indeed generate this mangled name given the
-# appropriate input, so the demangling is correct.
---format=auto --no-params
-__CPR212____ct__Q3_3std141list__tm__128_Q2_3edm41THandle__tm__26_Q2_4emid15EMparticleChunkQ2_3std68allocator__tm__51_Q2_3edmJ37J14const_iteratorFRCQ3_3std18list__tm__7_Z1ZZ2Z8iterator
-_Z1ZZ2Z::__CPR212____ct__Q3_3std141list__tm__128_Q2_3edm41THandle__tm__26_Q2_4emid15EMparticleChunkQ2_3std68allocator__tm__51_Q2_3edmJ37J14const_iteratorFRCQ3_3std18list__tm(iterator)
-_Z1ZZ2Z::__CPR212____ct__Q3_3std141list__tm__128_Q2_3edm41THandle__tm__26_Q2_4emid15EMparticleChunkQ2_3std68allocator__tm__51_Q2_3edmJ37J14const_iteratorFRCQ3_3std18list__tm
-#
 # This used to cause a crash. It doesn't follow the C++ encoding so
 # the demangled name should be identical to the original symbol name.
 --format=auto --no-params
@@ -4557,50 +1288,12 @@ void binary_left<1, 2, 3>(A<((42)+...+(1, 2, 3))>)
 
 _Z12binary_rightIJLi1ELi2ELi3EEEv1AIXfRplT_Li42EEE
 void binary_right<1, 2, 3>(A<((1, 2, 3)+...+(42))>)
-#
-# Tests a use-after-free problem PR70481
-
-_Q.__0
-::Q.(void)
-#
-# Tests a use-after-free problem PR70481
-
-_Q10-__9cafebabe.
-cafebabe.::-(void)
-#
-# Tests integer overflow problem PR70492
-
-__vt_90000000000cafebabe
-__vt_90000000000cafebabe
-#
-# Tests write access violation PR70498
-
-_Z80800000000000000000000
-_Z80800000000000000000000
-#
-# Tests write access violation PR70926
-
-0__Ot2m02R5T0000500000
-0__Ot2m02R5T0000500000
-#
-
-0__GT50000000000_
-0__GT50000000000_
-#
-
-__t2m05B500000000000000000_
-__t2m05B500000000000000000_
-#
-# Tests stack overflow PR71696
-
-__10%0__S4_0T0T0
-%0<>::%0(%0<>)
-
 # Inheriting constructor
+
 _ZN1DCI11BEi
 D::B(int)
-
 # exception-specification (C++17)
+
 _Z1fIvJiELb0EEvPDOT1_EFT_DpT0_E
 void f<void, int, false>(void (*)(int) noexcept(false))
 
@@ -4610,26 +1303,6 @@ void f<void, int, false>(void (*)(int) noexcept)
 _Z1fIvJiELb0EEvPDwiEFT_DpT0_E
 void f<void, int, false>(void (*)(int) throw(int))
 
-# Could crash
-_
-_
-
-# Could crash
-_vt
-_vt
-
-# Could crash
-_$_1Acitz
-_$_1Acitz
-
-# Could crash
-_$_H1R
-_$_H1R
-
-# Could crash
-_Q8ccQ4M2e.
-_Q8ccQ4M2e.
-
 # fold-expression with missing third component could crash.
 _Z12binary_rightIJLi1ELi2ELi3EEEv1AIXfRplT_LiEEE
 _Z12binary_rightIJLi1ELi2ELi3EEEv1AIXfRplT_LiEEE
@@ -4732,16 +1405,6 @@ _Z1MA_aMMMMA_MMA_MMMMMMMMSt1MS_o11T0000000000t2M0oooozoooo
 _Z4294967297x
 _Z4294967297x
 #
-# demangler/80513 Test for bogus characters after __thunk_
-
-__thunk_16a_$_1x
-__thunk_16a_$_1x
-#
-# demangler/80513 Test for overflow in consume_count
-
-__thunk_4294967297__$_1x
-__thunk_4294967297__$_1x
-#
 # demangler/82195 members of lambdas
 --no-params
 _ZZZ3FoovENKUlT_E_clIiEEfS_EN5Local2fnEv
