2018-06-12  Jason Merrill  <jason@redhat.com>

	PR c++/86098 - ICE with template placeholder for TTP.
	* typeck.c (structural_comptypes) [TEMPLATE_TYPE_PARM]: Check
	CLASS_PLACEHOLDER_TEMPLATE.

--- gcc/cp/typeck.c
+++ gcc/cp/typeck.c
@@ -1375,6 +1375,11 @@ structural_comptypes (tree t1, tree t2, int strict)
 	 template parameters set, they can't be equal.  */
       if (!comp_template_parms_position (t1, t2))
 	return false;
+      /* If T1 and T2 don't represent the same class template deduction,
+         they aren't equal.  */
+      if (CLASS_PLACEHOLDER_TEMPLATE (t1)
+	  != CLASS_PLACEHOLDER_TEMPLATE (t2))
+	return false;
       /* Constrained 'auto's are distinct from parms that don't have the same
 	 constraints.  */
       if (!equivalent_placeholder_constraints (t1, t2))
--- /dev/null
+++ gcc/testsuite/g++.dg/cpp1z/class-deduction58.C
@@ -0,0 +1,16 @@
+// PR c++/86098
+// { dg-additional-options -std=c++17 }
+
+template <class _Res> class future;
+template <class T> T&& declval();
+
+template<template <class...> class T>
+struct construct_deduced {
+  template <class... AN>
+  using deduced_t = decltype(T{declval<AN>()...});
+  template<class... AN>
+  deduced_t<AN...> operator()(AN&&... an) const;
+};
+
+template<class T>
+future<T> future_from(T singleSender);
